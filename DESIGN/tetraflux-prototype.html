<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRAFLUX - Prototype v0.1</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; font-size: 2.5rem; margin-bottom: 0.5rem; }
        .subtitle { text-align: center; color: #64748b; margin-bottom: 1.5rem; }
        .game-layout { display: flex; gap: 20px; flex-wrap: wrap; }
        .board-container {
            flex: 1;
            min-width: 500px;
            background: #1e293b;
            border-radius: 12px;
            padding: 20px;
            position: relative;
        }
        .side-panel { width: 280px; display: flex; flex-direction: column; gap: 16px; }
        .panel {
            background: #1e293b;
            border-radius: 12px;
            padding: 16px;
        }
        .panel-title { color: #64748b; font-size: 0.875rem; margin-bottom: 8px; }
        .current-player {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .color-dot {
            width: 24px;
            height: 24px;
            border-radius: 4px;
        }
        .player-name { font-weight: bold; font-size: 1.1rem; }
        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }
        .score-label { display: flex; align-items: center; gap: 8px; }
        .score-dot { width: 16px; height: 16px; border-radius: 4px; }
        .score-value { font-family: monospace; font-size: 1.1rem; }
        .divider { border: none; border-top: 1px solid #334155; margin: 8px 0; }
        .neutral-label { color: #64748b; font-size: 0.75rem; }
        .log-container {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.75rem;
        }
        .log-entry { padding: 2px 0; color: #cbd5e1; }
        .log-empty { color: #64748b; font-style: italic; }
        .legend { font-size: 0.75rem; line-height: 1.6; }
        .reset-btn {
            width: 100%;
            padding: 10px;
            background: #7f1d1d;
            color: #fecaca;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.2s;
        }
        .reset-btn:hover { background: #991b1b; }
        
        /* Orientation Picker Modal */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            z-index: 100;
        }
        .modal {
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 12px;
            padding: 20px;
            max-width: 400px;
        }
        .modal-title { text-align: center; font-weight: bold; margin-bottom: 8px; }
        .modal-hint { text-align: center; color: #64748b; font-size: 0.875rem; margin-bottom: 16px; }
        .orientation-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .orientation-column { text-align: center; }
        .orientation-label { font-size: 0.7rem; color: #64748b; margin-bottom: 4px; }
        .orientation-btn {
            width: 56px;
            height: 56px;
            border: 2px solid #475569;
            border-radius: 8px;
            background: #0f172a;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 4px auto;
            transition: all 0.2s;
        }
        .orientation-btn:hover { border-color: #22d3ee; background: #164e63; }
        .orientation-btn.recommended { border-color: #eab308; background: #1e293b; }
        .cancel-btn {
            width: 100%;
            padding: 8px;
            margin-top: 12px;
            background: #334155;
            color: #94a3b8;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        .cancel-btn:hover { background: #475569; }
        
        /* Instructions */
        .instructions {
            margin-top: 20px;
            background: #1e293b;
            border-radius: 12px;
            padding: 16px;
        }
        .instructions h3 { margin-bottom: 12px; }
        .rules-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            font-size: 0.875rem;
        }
        .rule-title { font-weight: 600; color: #e2e8f0; margin-bottom: 4px; }
        .rule-text { color: #94a3b8; }
        
        /* SVG styles */
        .cell { cursor: pointer; transition: all 0.15s; }
        .cell:hover polygon { fill: #0e7490; }
        .cell.occupied { cursor: default; }
        .cell.occupied:hover polygon { fill: #1e293b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>TETRAFLUX</h1>
        <p class="subtitle">Prototype v0.1 — Strategic Pyramid Placement</p>
        
        <div class="game-layout">
            <div class="board-container" id="board-container">
                <svg id="game-board" viewBox="-10 -10 400 380"></svg>
                <div id="modal-container"></div>
            </div>
            
            <div class="side-panel">
                <div class="panel">
                    <div class="panel-title">Current Turn</div>
                    <div class="current-player">
                        <div class="color-dot" id="current-color"></div>
                        <span class="player-name" id="current-name">Red</span>
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-title">Hidden Face Count (Score)</div>
                    <div id="scores"></div>
                </div>
                
                <div class="panel">
                    <div class="panel-title">Game Log</div>
                    <div class="log-container" id="game-log">
                        <div class="log-empty">Click a cell to place a piece</div>
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-title">Piece Legend</div>
                    <div class="legend">
                        • Center dot = Hidden face<br>
                        • Colored lines = Visible faces<br>
                        • Goal: Hide YOUR color<br>
                        • Matching visible faces = Collision
                    </div>
                </div>
                
                <button class="reset-btn" onclick="resetGame()">Reset Game</button>
            </div>
        </div>
        
        <div class="instructions">
            <h3>Quick Rules</h3>
            <div class="rules-grid">
                <div>
                    <div class="rule-title">Placement</div>
                    <div class="rule-text">Click empty cell → Choose which face to hide + rotation</div>
                </div>
                <div>
                    <div class="rule-title">Scoring</div>
                    <div class="rule-text">Count your color in the hidden position across ALL pieces</div>
                </div>
                <div>
                    <div class="rule-title">Collision</div>
                    <div class="rule-text">Matching visible colors touching = piece repelled (flips away)</div>
                </div>
                <div>
                    <div class="rule-title">Strategy</div>
                    <div class="rule-text">Hide your color. Expose opponent's. Neutrals are physics tools.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game Constants
        const COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#eab308'];
        const COLOR_NAMES = ['Red', 'Blue', 'Green', 'Yellow'];
        const GRID_SIZE = 5;
        
        // Game State
        let cells = [];
        let pieces = {};
        let currentPlayer = 0;
        let selectedCell = null;
        let gameLog = [];
        
        // Generate triangular grid
        function generateGrid() {
            cells = [];
            let id = 0;
            const cellSize = 40;
            const height = cellSize * Math.sqrt(3) / 2;
            
            for (let row = 0; row < GRID_SIZE * 2 - 1; row++) {
                const rowWidth = row < GRID_SIZE ? GRID_SIZE + row : GRID_SIZE * 3 - 2 - row;
                const offset = Math.abs(GRID_SIZE - 1 - row);
                
                for (let col = 0; col < rowWidth * 2; col++) {
                    const isUpward = col % 2 === 0;
                    cells.push({
                        id: id++,
                        row,
                        col,
                        isUpward,
                        x: offset * (cellSize / 2) + col * (cellSize / 2),
                        y: row * height
                    });
                }
            }
        }
        
        // Get visible faces based on hidden face and rotation
        function getVisibleFaces(hiddenFace, rotation) {
            const allFaces = [0, 1, 2, 3];
            const visible = allFaces.filter(f => f !== hiddenFace);
            const rotated = [...visible];
            for (let i = 0; i < rotation; i++) {
                rotated.push(rotated.shift());
            }
            return rotated;
        }
        
        // Find adjacent cells
        function findAdjacent(cellId) {
            const cell = cells.find(c => c.id === cellId);
            if (!cell) return [];
            return cells.filter(c => {
                if (c.id === cellId) return false;
                const dx = Math.abs(c.x - cell.x);
                const dy = Math.abs(c.y - cell.y);
                return dx <= 25 && dy <= 40 && (dx + dy) < 55;
            });
        }
        
        // Check for collision between two pieces
        function checkCollision(piece1, piece2) {
            const v1 = getVisibleFaces(piece1.hiddenFace, piece1.rotation);
            const v2 = getVisibleFaces(piece2.hiddenFace, piece2.rotation);
            for (const f1 of v1) {
                for (const f2 of v2) {
                    if (f1 === f2) return f1;
                }
            }
            return null;
        }
        
        // Render the game board
        function renderBoard() {
            const svg = document.getElementById('game-board');
            const cellSize = 40;
            const height = cellSize * Math.sqrt(3) / 2;
            
            let html = '';
            
            cells.forEach(cell => {
                const piece = pieces[cell.id];
                const isOccupied = !!piece;
                
                // Triangle points
                const points = cell.isUpward
                    ? `${cell.x + cellSize/2},${cell.y} ${cell.x},${cell.y + height} ${cell.x + cellSize},${cell.y + height}`
                    : `${cell.x},${cell.y} ${cell.x + cellSize},${cell.y} ${cell.x + cellSize/2},${cell.y + height}`;
                
                html += `<g class="cell ${isOccupied ? 'occupied' : ''}" data-id="${cell.id}" onclick="handleCellClick(${cell.id})">`;
                html += `<polygon points="${points}" fill="#1e293b" stroke="#334155" stroke-width="1"/>`;
                
                if (piece) {
                    const cx = cell.x + cellSize / 2;
                    const cy = cell.isUpward ? cell.y + height * 0.6 : cell.y + height * 0.4;
                    const visible = getVisibleFaces(piece.hiddenFace, piece.rotation);
                    
                    // Center dot (hidden face)
                    html += `<circle cx="${cx}" cy="${cy}" r="6" fill="${COLORS[piece.hiddenFace]}" stroke="#000" stroke-width="2"/>`;
                    
                    // Visible face indicators
                    visible.forEach((face, i) => {
                        const angle = (i * 120 - 90) * Math.PI / 180;
                        const x1 = cx + Math.cos(angle) * 8;
                        const y1 = cy + Math.sin(angle) * 8;
                        const x2 = cx + Math.cos(angle) * 16;
                        const y2 = cy + Math.sin(angle) * 16;
                        html += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${COLORS[face]}" stroke-width="4" stroke-linecap="round"/>`;
                    });
                }
                
                html += '</g>';
            });
            
            svg.innerHTML = html;
            
            // Update viewBox
            const maxX = Math.max(...cells.map(c => c.x)) + 50;
            const maxY = Math.max(...cells.map(c => c.y)) + 50;
            svg.setAttribute('viewBox', `-10 -10 ${maxX + 20} ${maxY + 20}`);
        }
        
        // Render scores
        function renderScores() {
            const scores = { 0: 0, 1: 0, 2: 0, 3: 0 };
            Object.values(pieces).forEach(p => scores[p.hiddenFace]++);
            
            let html = '';
            [0, 1].forEach(p => {
                html += `<div class="score-row">
                    <div class="score-label">
                        <div class="score-dot" style="background:${COLORS[p]}"></div>
                        <span>${COLOR_NAMES[p]}</span>
                    </div>
                    <span class="score-value">${scores[p]}</span>
                </div>`;
            });
            
            html += '<hr class="divider"><div class="neutral-label">Neutral colors:</div>';
            
            [2, 3].forEach(p => {
                html += `<div class="score-row">
                    <div class="score-label">
                        <div class="score-dot" style="background:${COLORS[p]};width:12px;height:12px"></div>
                        <span style="color:#64748b;font-size:0.875rem">${COLOR_NAMES[p]}</span>
                    </div>
                    <span class="score-value" style="color:#64748b;font-size:0.875rem">${scores[p]}</span>
                </div>`;
            });
            
            document.getElementById('scores').innerHTML = html;
        }
        
        // Render current player
        function renderCurrentPlayer() {
            document.getElementById('current-color').style.background = COLORS[currentPlayer];
            document.getElementById('current-name').textContent = COLOR_NAMES[currentPlayer];
        }
        
        // Add to game log
        function addLog(message) {
            gameLog.push(message);
            if (gameLog.length > 10) gameLog.shift();
            
            const container = document.getElementById('game-log');
            container.innerHTML = gameLog.map(m => `<div class="log-entry">${m}</div>`).join('');
            container.scrollTop = container.scrollHeight;
        }
        
        // Handle cell click
        function handleCellClick(cellId) {
            if (pieces[cellId]) return;
            selectedCell = cellId;
            showOrientationPicker();
        }
        
        // Show orientation picker modal
        function showOrientationPicker() {
            const container = document.getElementById('modal-container');
            
            let html = `<div class="modal-overlay">
                <div class="modal">
                    <div class="modal-title">Choose Orientation</div>
                    <div class="modal-hint">Center dot = hidden face (Goal: hide ${COLOR_NAMES[currentPlayer]})</div>
                    <div class="orientation-grid">`;
            
            for (let hidden = 0; hidden < 4; hidden++) {
                html += `<div class="orientation-column">
                    <div class="orientation-label">Hide ${COLOR_NAMES[hidden]}</div>`;
                
                for (let rot = 0; rot < 3; rot++) {
                    const visible = getVisibleFaces(hidden, rot);
                    const isRecommended = hidden === currentPlayer;
                    
                    html += `<button class="orientation-btn ${isRecommended ? 'recommended' : ''}" 
                        onclick="selectOrientation(${hidden}, ${rot})">
                        <svg width="40" height="40" viewBox="0 0 40 40">
                            <circle cx="20" cy="20" r="6" fill="${COLORS[hidden]}" stroke="#000" stroke-width="1"/>`;
                    
                    visible.forEach((face, i) => {
                        const angle = (i * 120 - 90) * Math.PI / 180;
                        html += `<line x1="${20 + Math.cos(angle) * 8}" y1="${20 + Math.sin(angle) * 8}" 
                            x2="${20 + Math.cos(angle) * 16}" y2="${20 + Math.sin(angle) * 16}" 
                            stroke="${COLORS[face]}" stroke-width="3" stroke-linecap="round"/>`;
                    });
                    
                    html += `</svg></button>`;
                }
                html += '</div>';
            }
            
            html += `</div>
                <button class="cancel-btn" onclick="hideOrientationPicker()">Cancel</button>
                </div></div>`;
            
            container.innerHTML = html;
        }
        
        // Hide orientation picker
        function hideOrientationPicker() {
            document.getElementById('modal-container').innerHTML = '';
            selectedCell = null;
        }
        
        // Select orientation and place piece
        function selectOrientation(hiddenFace, rotation) {
            if (selectedCell === null) return;
            
            const newPiece = { hiddenFace, rotation, owner: currentPlayer };
            
            // Check collisions
            const adjacent = findAdjacent(selectedCell);
            const collisions = [];
            
            adjacent.forEach(adj => {
                if (pieces[adj.id]) {
                    const collision = checkCollision(newPiece, pieces[adj.id]);
                    if (collision !== null) {
                        collisions.push({ cellId: adj.id, color: collision });
                    }
                }
            });
            
            // Place piece
            pieces[selectedCell] = newPiece;
            
            addLog(`${COLOR_NAMES[currentPlayer]} placed (hiding ${COLOR_NAMES[hiddenFace]})`);
            
            if (collisions.length > 0) {
                addLog(`⚡ ${collisions.length} collision(s) detected!`);
                collisions.forEach(c => {
                    addLog(`  → ${COLOR_NAMES[c.color]} clash at cell ${c.cellId}`);
                });
            }
            
            hideOrientationPicker();
            currentPlayer = (currentPlayer + 1) % 2;
            
            renderBoard();
            renderScores();
            renderCurrentPlayer();
        }
        
        // Reset game
        function resetGame() {
            pieces = {};
            currentPlayer = 0;
            gameLog = [];
            selectedCell = null;
            
            document.getElementById('game-log').innerHTML = '<div class="log-empty">Click a cell to place a piece</div>';
            
            renderBoard();
            renderScores();
            renderCurrentPlayer();
        }
        
        // Initialize
        generateGrid();
        renderBoard();
        renderScores();
        renderCurrentPlayer();
    </script>
</body>
</html>
