<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRAFLUX - Full Prototype v0.2</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #e2e8f0;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { 
            text-align: center; 
            font-size: 2.5rem; 
            margin-bottom: 0.25rem;
            background: linear-gradient(90deg, #f59e0b, #ef4444, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle { text-align: center; color: #64748b; margin-bottom: 1rem; }
        .game-layout { display: flex; gap: 20px; flex-wrap: wrap; }
        .board-container {
            flex: 1;
            min-width: 600px;
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            padding: 20px;
            position: relative;
            border: 1px solid #334155;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .side-panel { width: 320px; display: flex; flex-direction: column; gap: 12px; }
        .panel {
            background: linear-gradient(180deg, #1e293b 0%, #172033 100%);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #334155;
        }
        .panel-title { 
            color: #64748b; 
            font-size: 0.75rem; 
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px; 
        }
        .current-player {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .color-dot {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            box-shadow: 0 0 20px currentColor;
        }
        .player-name { font-weight: bold; font-size: 1.25rem; }
        .player-type { color: #64748b; font-size: 0.875rem; }
        
        /* Mode selector */
        .mode-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        .mode-btn {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #334155;
            background: #0f172a;
            color: #94a3b8;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        .mode-btn:hover { border-color: #64748b; }
        .mode-btn.active {
            border-color: #3b82f6;
            background: #1e3a5f;
            color: #60a5fa;
        }
        
        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
        }
        .score-label { display: flex; align-items: center; gap: 10px; }
        .score-dot { 
            width: 20px; 
            height: 20px; 
            border-radius: 4px;
            box-shadow: 0 0 10px currentColor;
        }
        .score-value { 
            font-family: 'Courier New', monospace; 
            font-size: 1.25rem;
            font-weight: bold;
        }
        .score-bar {
            height: 4px;
            background: #334155;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }
        .score-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .divider { border: none; border-top: 1px solid #334155; margin: 10px 0; }
        .neutral-label { color: #475569; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em; }
        
        .log-container {
            max-height: 180px;
            overflow-y: auto;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }
        .log-entry { 
            padding: 3px 0; 
            color: #94a3b8;
            border-bottom: 1px solid #1e293b;
        }
        .log-entry.collision { color: #fbbf24; }
        .log-entry.destruction { color: #ef4444; }
        .log-entry.exile { color: #a855f7; }
        .log-entry.cascade { color: #22d3ee; }
        .log-entry.ai { color: #22c55e; }
        .log-empty { color: #475569; font-style: italic; }
        
        .legend { font-size: 0.8rem; line-height: 1.8; }
        .legend-item { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .reset-btn {
            background: linear-gradient(135deg, #7f1d1d, #991b1b);
            color: #fecaca;
        }
        .reset-btn:hover { background: linear-gradient(135deg, #991b1b, #b91c1c); }
        
        .ai-btn {
            background: linear-gradient(135deg, #065f46, #047857);
            color: #a7f3d0;
            margin-bottom: 8px;
        }
        .ai-btn:hover { background: linear-gradient(135deg, #047857, #059669); }
        .ai-btn:disabled { 
            background: #1e293b; 
            color: #475569; 
            cursor: not-allowed; 
        }
        
        /* Modal */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
            z-index: 100;
            backdrop-filter: blur(4px);
        }
        .modal {
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid #475569;
            border-radius: 16px;
            padding: 24px;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .modal-title { text-align: center; font-weight: bold; font-size: 1.1rem; margin-bottom: 8px; }
        .modal-hint { text-align: center; color: #64748b; font-size: 0.8rem; margin-bottom: 20px; }
        .orientation-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        .orientation-column { text-align: center; }
        .orientation-label { 
            font-size: 0.65rem; 
            color: #64748b; 
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .orientation-btn {
            width: 52px;
            height: 52px;
            border: 2px solid #334155;
            border-radius: 10px;
            background: #0f172a;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 4px auto;
            transition: all 0.2s;
        }
        .orientation-btn:hover { 
            border-color: #22d3ee; 
            background: #164e63;
            transform: scale(1.05);
        }
        .orientation-btn.recommended { 
            border-color: #eab308; 
            background: #422006;
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.3);
        }
        .cancel-btn {
            width: 100%;
            padding: 10px;
            margin-top: 16px;
            background: #334155;
            color: #94a3b8;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
        }
        .cancel-btn:hover { background: #475569; }
        
        /* Flee choice modal */
        .flee-modal {
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid #f59e0b;
            border-radius: 16px;
            padding: 24px;
            max-width: 350px;
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.3);
        }
        .flee-btn {
            padding: 12px 20px;
            margin: 6px;
            border: 2px solid #475569;
            border-radius: 8px;
            background: #1e293b;
            color: #e2e8f0;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .flee-btn:hover {
            border-color: #22d3ee;
            background: #164e63;
        }
        .flee-btn.exile {
            border-color: #a855f7;
            color: #c4b5fd;
        }
        .flee-btn.exile:hover {
            background: #3b0764;
        }
        
        /* Stats panel */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .stat-box {
            background: #0f172a;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
        .stat-label { font-size: 0.65rem; color: #64748b; text-transform: uppercase; }
        
        /* Animation for cascades */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .cascading { animation: pulse 0.3s ease-in-out; }
        
        /* Game over */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid #eab308;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 0 60px rgba(234, 179, 8, 0.4);
        }
        .game-over h2 { font-size: 2rem; margin-bottom: 10px; color: #fbbf24; }
        .winner-display { font-size: 1.5rem; margin: 20px 0; }
        .final-scores { margin: 20px 0; }
        
        /* Instructions */
        .instructions {
            margin-top: 20px;
            background: linear-gradient(180deg, #1e293b 0%, #172033 100%);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #334155;
        }
        .instructions h3 { margin-bottom: 16px; color: #f59e0b; }
        .rules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            font-size: 0.875rem;
        }
        .rule-box {
            background: #0f172a;
            border-radius: 8px;
            padding: 14px;
            border-left: 3px solid #3b82f6;
        }
        .rule-title { font-weight: 600; color: #e2e8f0; margin-bottom: 6px; }
        .rule-text { color: #94a3b8; line-height: 1.5; }
        
        /* SVG styles */
        .cell { transition: all 0.15s; }
        .cell polygon { transition: all 0.15s; }
        .cell.valid-target { cursor: pointer; }
        .cell.valid-target:hover polygon { fill: #0e7490 !important; }
        .cell.occupied { cursor: default; }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚¨° TETRAFLUX ‚¨°</h1>
        <p class="subtitle">Strategic Pyramid Warfare ‚Äî Full Prototype v0.2</p>
        
        <div class="game-layout">
            <div class="board-container" id="board-container">
                <svg id="game-board"></svg>
                <div id="modal-container"></div>
                <div id="game-over-container"></div>
            </div>
            
            <div class="side-panel">
                <!-- Game Setup -->
                <div class="panel">
                    <div class="panel-title">Game Setup</div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 0.8rem; color: #94a3b8;">Players:</span>
                            <select id="player-count" onchange="updatePlayerConfig()" style="background: #0f172a; color: #e2e8f0; border: 1px solid #334155; padding: 4px; border-radius: 4px;">
                                <option value="2">2 Players</option>
                                <option value="3">3 Players</option>
                                <option value="4">4 Players</option>
                            </select>
                        </div>
                        <div id="player-config-list" style="display: flex; flex-direction: column; gap: 4px;">
                            <!-- Populated by JS -->
                        </div>
                        <button class="btn" onclick="applySetupAndReset()" style="background: #3b82f6; color: white; padding: 8px; font-size: 0.8rem; margin-top: 4px;">
                            Apply & Restart
                        </button>
                    </div>
                </div>

                <!-- Current Player -->
                <div class="panel">
                    <div class="panel-title">Current Turn</div>
                    <div class="current-player">
                        <div class="color-dot" id="current-color"></div>
                        <div>
                            <div class="player-name" id="current-name">Red</div>
                            <div class="player-type" id="current-type">Human</div>
                        </div>
                    </div>
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 8px;">
                        Shortcuts: <span style="color: #e2e8f0; font-weight: bold;">R</span> = Rotate, <span style="color: #e2e8f0; font-weight: bold;">F</span> = Flip
                    </div>
                    <button class="btn ai-btn" id="ai-move-btn" onclick="executeAITurn()" style="margin-top: 12px; display: none;">
                        ü§ñ Execute AI Move
                    </button>
                </div>
                
                <!-- Scores -->
                <div class="panel">
                    <div class="panel-title">Hidden Face Score</div>
                    <div id="scores"></div>
                </div>
                
                <!-- Game Stats -->
                <div class="panel">
                    <div class="panel-title">Board Statistics</div>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value" id="stat-pieces">0</div>
                            <div class="stat-label">Pieces</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="stat-empty">0</div>
                            <div class="stat-label">Empty</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="stat-exiled">0</div>
                            <div class="stat-label">Exiled</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="stat-destroyed">0</div>
                            <div class="stat-label">Destroyed</div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Log -->
                <div class="panel">
                    <div class="panel-title">Event Log</div>
                    <div class="log-container" id="game-log">
                        <div class="log-empty">Click a cell to begin</div>
                    </div>
                </div>
                
                <!-- Legend -->
                <div class="panel">
                    <div class="panel-title">Piece Legend</div>
                    <div class="legend">
                        <div class="legend-item">
                            <svg width="20" height="20"><circle cx="10" cy="10" r="6" fill="#eab308" stroke="#000" stroke-width="1"/></svg>
                            <span>Center = Hidden face (scoring)</span>
                        </div>
                        <div class="legend-item">
                            <svg width="20" height="20"><line x1="2" y1="10" x2="18" y2="10" stroke="#3b82f6" stroke-width="4" stroke-linecap="round"/></svg>
                            <span>Lines = Visible faces (collision)</span>
                        </div>
                    </div>
                </div>
                
                <!-- Controls -->
                <button class="btn reset-btn" onclick="resetGame()">üîÑ Reset Game</button>
            </div>
        </div>
        
        <div class="instructions">
            <h3>‚ö° Game Mechanics</h3>
            <div class="rules-grid">
                <div class="rule-box">
                    <div class="rule-title">üéØ Objective</div>
                    <div class="rule-text">Hide your color face-down on as many pieces as possible. Score = count of your color in hidden position across ALL pieces.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üí• Collision</div>
                    <div class="rule-text">When visible faces of same color touch, the stationary piece is REPELLED ‚Äî it flips one space away, changing its hidden face.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üåä Cascade</div>
                    <div class="rule-text">Repelled pieces may cause new collisions, triggering chain reactions. All cascades resolve before turn ends.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üö™ Exile</div>
                    <div class="rule-text">Pieces pushed off the board are EXILED ‚Äî removed from play. Edge positions are vulnerable but always have an escape route.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üíÄ Destruction</div>
                    <div class="rule-text">If a piece cannot flee (fully surrounded, no edges), BOTH colliding pieces are destroyed. Mutual annihilation.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">ü§ù Hidden Cooperation</div>
                    <div class="rule-text">Aggressive play is volatile ‚Äî cascades are unpredictable. Stable boards preserve everyone's scores. Fight in the middle, leave edges peaceful.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // TETRAFLUX - Complete Game Engine v0.2
        // ============================================
        
        // Constants
        const COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#eab308'];
        const COLOR_NAMES = ['Red', 'Blue', 'Green', 'Yellow'];
        const GRID_SIZE = 5;
        
        // Tetrahedron face relationships
        // When tumbling over an edge, the hidden face changes deterministically
        // Face indices: 0=Red, 1=Blue, 2=Green, 3=Yellow
        // Edge indices for each face: 0=left, 1=right, 2=back
        const FLIP_MAP = {
            // [currentHidden][edgeIndex] = newHidden
            0: [1, 2, 3], // Red hidden, flip over edge 0/1/2 ‚Üí Blue/Green/Yellow hidden
            1: [0, 3, 2], // Blue hidden
            2: [3, 0, 1], // Green hidden
            3: [2, 1, 0], // Yellow hidden
        };
        
        // Game State
        let cells = [];
        let pieces = {};
        let currentPlayer = 0;
        let selectedCell = null;
        let gameLog = [];
        let gameMode = 'pvp'; // 'pvp' or 'ai'
        let gameOver = false;
        let stats = { exiled: 0, destroyed: 0 };
        let pendingFleeChoice = null;
        
        // New State for v0.2.1
        let ghostPiece = null; // { cellId, hiddenFace, rotation }
        let players = [
            { id: 0, type: 'human', active: true },
            { id: 1, type: 'human', active: true },
            { id: 2, type: 'human', active: false },
            { id: 3, type: 'human', active: false }
        ];
        
        // ============================================
        // GRID GENERATION
        // ============================================
        
        function generateGrid() {
            cells = [];
            let id = 0;
            const cellSize = 36;
            const height = cellSize * Math.sqrt(3) / 2;
            
            // 1. Generate full hexagon
            let tempCells = [];
            for (let row = 0; row < GRID_SIZE * 2 - 1; row++) {
                const rowWidth = row < GRID_SIZE ? GRID_SIZE + row : GRID_SIZE * 3 - 2 - row;
                const offset = Math.abs(GRID_SIZE - 1 - row);
                
                for (let col = 0; col < rowWidth * 2; col++) {
                    const isUpward = col % 2 === 0;
                    const x = offset * (cellSize / 2) + col * (cellSize / 2);
                    const y = row * height;
                    
                    tempCells.push({
                        id: id++,
                        row,
                        col,
                        rowWidth,
                        isUpward,
                        x,
                        y,
                        cellSize,
                        height
                    });
                }
            }
            
            // 2. Remove "teeth" (cells with < 2 neighbors)
            // This prevents the "2 vacant off-board spaces" vulnerability
            const getNeighborCount = (cell, allCells) => {
                let count = 0;
                allCells.forEach(c => {
                    if (c.id === cell.id) return;
                    const dx = Math.abs(c.x - cell.x);
                    const dy = Math.abs(c.y - cell.y);
                    // Check for shared edge
                    if (dx <= cellSize * 0.6 && dy <= height * 1.1 && (dx + dy) < cellSize * 1.2) {
                        count++;
                    }
                });
                return count;
            };
            
            // Filter out cells with fewer than 2 neighbors (corners/teeth)
            cells = tempCells.filter(cell => getNeighborCount(cell, tempCells) >= 2);
            
            // 3. Calculate isEdge for remaining cells
            cells.forEach(cell => {
                const neighbors = getNeighborCount(cell, cells);
                cell.isEdge = neighbors < 3; // Triangle has 3 sides, so < 3 neighbors means it's on edge
            });
        }
        
        // ============================================
        // TETRAHEDRON MECHANICS
        // ============================================
        
        function getVisibleFaces(hiddenFace, rotation) {
            const allFaces = [0, 1, 2, 3];
            const visible = allFaces.filter(f => f !== hiddenFace);
            const rotated = [...visible];
            for (let i = 0; i < rotation; i++) {
                rotated.push(rotated.shift());
            }
            return rotated; // [edge0, edge1, edge2]
        }
        
        function flipPiece(piece, edgeIndex) {
            // Determine new hidden face after tumbling over given edge
            const newHidden = FLIP_MAP[piece.hiddenFace][edgeIndex];
            // Rotation also changes - simplified: increment by 1
            const newRotation = (piece.rotation + 1) % 3;
            return {
                ...piece,
                hiddenFace: newHidden,
                rotation: newRotation
            };
        }
        
        // ============================================
        // ADJACENCY & COLLISION
        // ============================================
        
        function findAdjacent(cellId) {
            const cell = cells.find(c => c.id === cellId);
            if (!cell) return [];
            
            const adjacent = [];
            const { cellSize, height } = cell;
            
            cells.forEach(c => {
                if (c.id === cellId) return;
                const dx = Math.abs(c.x - cell.x);
                const dy = Math.abs(c.y - cell.y);
                
                // Adjacent triangles share an edge
                if (dx <= cellSize * 0.6 && dy <= height * 1.1 && (dx + dy) < cellSize * 1.2) {
                    // Determine which edge connects them
                    let edgeIndex = 0;
                    if (cell.isUpward) {
                        if (c.y < cell.y) edgeIndex = 2; // back/top
                        else if (c.x < cell.x) edgeIndex = 0; // left
                        else edgeIndex = 1; // right
                    } else {
                        if (c.y > cell.y) edgeIndex = 2; // back/bottom
                        else if (c.x < cell.x) edgeIndex = 0; // left
                        else edgeIndex = 1; // right
                    }
                    adjacent.push({ cell: c, edgeIndex });
                }
            });
            
            return adjacent;
        }
        
        function getFleeDirections(cellId) {
            const adjacent = findAdjacent(cellId);
            const cell = cells.find(c => c.id === cellId);
            const directions = [];
            
            // Check each adjacent position
            adjacent.forEach(({ cell: adjCell, edgeIndex }) => {
                if (!pieces[adjCell.id]) {
                    directions.push({
                        targetCell: adjCell,
                        edgeIndex,
                        isExile: false
                    });
                }
            });
            
            // Check for edge exile
            if (cell.isEdge) {
                // Determine which edges lead off-board
                const { row, col, rowWidth, isUpward } = cell;
                
                // Top edge
                if (row === 0 && isUpward) {
                    directions.push({ targetCell: null, edgeIndex: 2, isExile: true });
                }
                // Bottom edge
                if (row === GRID_SIZE * 2 - 2 && !isUpward) {
                    directions.push({ targetCell: null, edgeIndex: 2, isExile: true });
                }
                // Left edge
                if (col === 0) {
                    directions.push({ targetCell: null, edgeIndex: 0, isExile: true });
                }
                // Right edge
                if (col === rowWidth * 2 - 1) {
                    directions.push({ targetCell: null, edgeIndex: 1, isExile: true });
                }
            }
            
            return directions;
        }
        
        function checkCollision(piece1, piece2) {
            const v1 = getVisibleFaces(piece1.hiddenFace, piece1.rotation);
            const v2 = getVisibleFaces(piece2.hiddenFace, piece2.rotation);
            
            for (const f1 of v1) {
                for (const f2 of v2) {
                    if (f1 === f2) return f1;
                }
            }
            return null;
        }
        
        // ============================================
        // CASCADE RESOLUTION
        // ============================================
        
        function resolveCollisions(triggerCellId, newPieceCellId) {
            const cascadeQueue = [];
            const processed = new Set();
            
            // Initial collision check
            const adjacent = findAdjacent(triggerCellId);
            adjacent.forEach(({ cell: adjCell, edgeIndex }) => {
                if (adjCell.id === newPieceCellId) return; // Don't check against the piece that just moved here
                if (pieces[adjCell.id] && pieces[triggerCellId]) {
                    const collision = checkCollision(pieces[triggerCellId], pieces[adjCell.id]);
                    if (collision !== null) {
                        cascadeQueue.push({
                            attackerId: triggerCellId,
                            defenderId: adjCell.id,
                            color: collision
                        });
                    }
                }
            });
            
            // Also check if the new piece causes collisions
            if (newPieceCellId !== triggerCellId) {
                const newAdjacent = findAdjacent(newPieceCellId);
                newAdjacent.forEach(({ cell: adjCell }) => {
                    if (adjCell.id === triggerCellId) return;
                    if (pieces[adjCell.id] && pieces[newPieceCellId]) {
                        const collision = checkCollision(pieces[newPieceCellId], pieces[adjCell.id]);
                        if (collision !== null && !cascadeQueue.some(c => c.defenderId === adjCell.id)) {
                            cascadeQueue.push({
                                attackerId: newPieceCellId,
                                defenderId: adjCell.id,
                                color: collision
                            });
                        }
                    }
                });
            }
            
            return cascadeQueue;
        }
        
        async function processCascade(collision) {
            const { attackerId, defenderId, color } = collision;
            const defender = pieces[defenderId];
            
            if (!defender) return []; // Already removed
            
            addLog(`üí• ${COLOR_NAMES[color]} collision!`, 'collision');
            
            const fleeOptions = getFleeDirections(defenderId);
            
            if (fleeOptions.length === 0) {
                // Mutual destruction
                addLog(`üíÄ Mutual destruction!`, 'destruction');
                delete pieces[attackerId];
                delete pieces[defenderId];
                stats.destroyed += 2;
                return [];
            }
            
            // Determine flee direction
            let chosenFlee;
            
            if (fleeOptions.length === 1) {
                chosenFlee = fleeOptions[0];
            } else {
                // Owner chooses - for AI or if it's opponent's piece during their turn
                const defenderOwner = defender.owner;
                
                if (players[defenderOwner].type === 'ai') {
                    // AI chooses flee direction
                    chosenFlee = aiChooseFleeDirection(fleeOptions, defenderId);
                    addLog(`ü§ñ AI chose flee direction`, 'ai');
                } else if (players[defenderOwner].type === 'human') {
                    // Human chooses
                    chosenFlee = await humanChooseFleeDirection(fleeOptions, defenderId);
                } else {
                    // Should not happen if all players are configured, but fallback
                    chosenFlee = fleeOptions.find(f => !f.isExile) || fleeOptions[0];
                }
            }
            
            // Execute flee
            if (chosenFlee.isExile) {
                addLog(`üö™ Piece exiled from board!`, 'exile');
                delete pieces[defenderId];
                stats.exiled++;
                return [];
            } else {
                // Flip and move
                const flippedPiece = flipPiece(defender, chosenFlee.edgeIndex);
                delete pieces[defenderId];
                pieces[chosenFlee.targetCell.id] = flippedPiece;
                
                addLog(`‚Ü™ Piece flipped to cell ${chosenFlee.targetCell.id}`, 'cascade');
                
                // Check for new collisions at destination
                renderBoard();
                await sleep(200);
                
                return resolveCollisions(chosenFlee.targetCell.id, chosenFlee.targetCell.id);
            }
        }
        
        function humanChooseFleeDirection(options, defenderId) {
            return new Promise(resolve => {
                pendingFleeChoice = { options, defenderId, resolve };
                showFleeChoiceModal(options, defenderId);
            });
        }
        
        function showFleeChoiceModal(options, defenderId) {
            const container = document.getElementById('modal-container');
            const defenderOwner = pieces[defenderId]?.owner;
            
            let html = `<div class="modal-overlay">
                <div class="flee-modal">
                    <div class="modal-title">‚ö° Choose Flee Direction</div>
                    <div class="modal-hint">${COLOR_NAMES[defenderOwner]}'s piece must flee! Choose destination:</div>
                    <div style="display: flex; flex-wrap: wrap; justify-content: center;">`;
            
            options.forEach((opt, idx) => {
                if (opt.isExile) {
                    html += `<button class="flee-btn exile" onclick="selectFleeDirection(${idx})">
                        üö™ Exile (Off Board)
                    </button>`;
                } else {
                    html += `<button class="flee-btn" onclick="selectFleeDirection(${idx})">
                        ‚Üí Cell ${opt.targetCell.id}
                    </button>`;
                }
            });
            
            html += `</div></div></div>`;
            container.innerHTML = html;
        }
        
        function selectFleeDirection(index) {
            if (pendingFleeChoice) {
                const choice = pendingFleeChoice.options[index];
                document.getElementById('modal-container').innerHTML = '';
                pendingFleeChoice.resolve(choice);
                pendingFleeChoice = null;
            }
        }
        
        // ============================================
        // AI OPPONENT
        // ============================================
        
        function aiChooseFleeDirection(options, defenderId) {
            const piece = pieces[defenderId];
            if (!piece) return options[0];
            
            // Priority: 
            // 1. Flip toward empty interior
            // 2. Flip toward opponent cluster
            // 3. Exile only to avoid exposing AI color
            
            const nonExile = options.filter(o => !o.isExile);
            if (nonExile.length > 0) {
                // Prefer interior positions
                const interior = nonExile.filter(o => !o.targetCell.isEdge);
                if (interior.length > 0) return interior[0];
                return nonExile[0];
            }
            
            // Must exile
            return options.find(o => o.isExile) || options[0];
        }
        
        function evaluatePlacement(cellId, hiddenFace, rotation) {
            let score = 0;
            const piece = { hiddenFace, rotation, owner: currentPlayer };
            
            // Priority 1: Bury AI color
            if (hiddenFace === currentPlayer) score += 100;
            
            // Priority 4: Claim interior
            const cell = cells.find(c => c.id === cellId);
            if (!cell.isEdge) score += 20;
            
            // Priority 2: Avoid exposing AI color through cascades
            const visible = getVisibleFaces(hiddenFace, rotation);
            const adjacent = findAdjacent(cellId);
            
            let collisionRisk = 0;
            adjacent.forEach(({ cell: adjCell }) => {
                if (pieces[adjCell.id]) {
                    const collision = checkCollision(piece, pieces[adjCell.id]);
                    if (collision !== null) {
                        collisionRisk++;
                        // Priority 3: Threaten opponent's buried colors
                        if (pieces[adjCell.id].owner !== currentPlayer) {
                            score += 10;
                        }
                    }
                }
            });
            
            // Penalize high collision risk (unpredictable cascades)
            score -= collisionRisk * 15;
            
            // Priority 5: Use neutrals strategically (if any)
            // In 4 player game, there are no neutrals, but in 2 player there are.
            // If hiddenFace is not current player and not an active opponent...
            // But for now, just prefer hiding own color.
            if (hiddenFace !== currentPlayer) {
                score -= 30; 
            }
            
            return score;
        }
        
        function getAIMove() {
            const emptyCells = cells.filter(c => !pieces[c.id]);
            if (emptyCells.length === 0) return null;
            
            let bestMove = null;
            let bestScore = -Infinity;
            
            emptyCells.forEach(cell => {
                for (let hidden = 0; hidden < 4; hidden++) {
                    for (let rot = 0; rot < 3; rot++) {
                        const score = evaluatePlacement(cell.id, hidden, rot);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { cellId: cell.id, hiddenFace: hidden, rotation: rot };
                        }
                    }
                }
            });
            
            return bestMove;
        }
        
        async function executeAITurn() {
            if (gameOver || players[currentPlayer].type !== 'ai') return;
            
            document.getElementById('ai-move-btn').disabled = true;
            
            await sleep(500);
            
            const move = getAIMove();
            if (!move) {
                checkGameOver();
                return;
            }
            
            addLog(`ü§ñ AI placing piece...`, 'ai');
            await sleep(300);
            
            await placePiece(move.cellId, move.hiddenFace, move.rotation);
            
            document.getElementById('ai-move-btn').disabled = false;
        }
        
        // ============================================
        // GAME FLOW
        // ============================================
        
        async function placePiece(cellId, hiddenFace, rotation) {
            if (pieces[cellId] || gameOver) return;
            
            const newPiece = { 
                hiddenFace, 
                rotation, 
                owner: currentPlayer 
            };
            
            pieces[cellId] = newPiece;
            addLog(`${COLOR_NAMES[currentPlayer]} placed (hiding ${COLOR_NAMES[hiddenFace]})`);
            
            renderBoard();
            await sleep(100);
            
            // Check for collisions
            let cascadeQueue = resolveCollisions(cellId, cellId);
            
            while (cascadeQueue.length > 0) {
                const collision = cascadeQueue.shift();
                const newCollisions = await processCascade(collision);
                cascadeQueue.push(...newCollisions);
                renderBoard();
                await sleep(150);
            }
            
            hideOrientationPicker();
            
            if (!checkGameOver()) {
                // Find next active player
                let nextPlayer = (currentPlayer + 1) % 4;
                while (!players[nextPlayer].active) {
                    nextPlayer = (nextPlayer + 1) % 4;
                }
                currentPlayer = nextPlayer;
                
                renderAll();
                
                // Auto-trigger AI if it's AI's turn
                if (players[currentPlayer].type === 'ai') {
                    setTimeout(() => executeAITurn(), 500);
                }
            }
        }
        
        function checkGameOver() {
            const emptyCells = cells.filter(c => !pieces[c.id]);
            if (emptyCells.length === 0) {
                gameOver = true;
                showGameOver();
                return true;
            }
            return false;
        }
        
        function showGameOver() {
            const scores = calculateScores();
            
            let winner = null;
            let maxScore = -1;
            let isTie = false;
            
            players.forEach(p => {
                if (!p.active) return;
                if (scores[p.id] > maxScore) {
                    maxScore = scores[p.id];
                    winner = p;
                    isTie = false;
                } else if (scores[p.id] === maxScore) {
                    isTie = true;
                }
            });
            
            let winnerText, winnerColor;
            if (isTie) {
                winnerText = "It's a Tie!";
                winnerColor = '#94a3b8';
            } else {
                winnerText = `${COLOR_NAMES[winner.id]} Wins!`;
                winnerColor = COLORS[winner.id];
            }
            
            const container = document.getElementById('game-over-container');
            
            let scoresHtml = '<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">';
            players.forEach(p => {
                if (!p.active) return;
                scoresHtml += `
                    <div style="text-align: center;">
                        <div style="color: ${COLORS[p.id]}; font-size: 2rem; font-weight: bold;">${scores[p.id]}</div>
                        <div style="color: #94a3b8;">${COLOR_NAMES[p.id]}</div>
                    </div>
                `;
            });
            scoresHtml += '</div>';

            container.innerHTML = `
                <div class="game-over">
                    <h2>üèÜ Game Over!</h2>
                    <div class="winner-display" style="color: ${winnerColor}">
                        ${winnerText}
                    </div>
                    <div class="final-scores">
                        ${scoresHtml}
                    </div>
                    <button class="btn reset-btn" onclick="resetGame()" style="margin-top: 20px;">
                        üîÑ Play Again
                    </button>
                </div>
            `;
        }
        
        // ============================================
        // UI HANDLERS
        // ============================================
        
        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (gameOver || !ghostPiece) return;
            
            // Only allow manipulation if it's human turn
            if (players[currentPlayer].type !== 'human') return;

            switch(e.key.toLowerCase()) {
                case 'r':
                    ghostPiece.rotation = (ghostPiece.rotation + 1) % 3;
                    renderBoard();
                    break;
                case 'f':
                    // Cycle through valid hidden faces
                    // For simplicity, just cycle 0-3, but maybe we should skip inactive players?
                    // Let's just cycle 0-3 for now, player can choose to hide neutral
                    ghostPiece.hiddenFace = (ghostPiece.hiddenFace + 1) % 4;
                    renderBoard();
                    break;
                case 'enter':
                    if (ghostPiece) {
                        placePiece(ghostPiece.cellId, ghostPiece.hiddenFace, ghostPiece.rotation);
                    }
                    break;
                case 'escape':
                    ghostPiece = null;
                    renderBoard();
                    break;
            }
        });

        function handleCellClick(cellId) {
            if (pieces[cellId] || gameOver) return;
            if (players[currentPlayer].type === 'ai') return; // AI's turn
            
            // If clicking the same cell with ghost piece, confirm placement
            if (ghostPiece && ghostPiece.cellId === cellId) {
                placePiece(cellId, ghostPiece.hiddenFace, ghostPiece.rotation);
                return;
            }

            // Otherwise, move ghost piece here
            // Default: Hide current player's color, rotation 0
            ghostPiece = {
                cellId,
                hiddenFace: currentPlayer,
                rotation: 0
            };
            renderBoard();
        }
        
        // Deprecated: showOrientationPicker, hideOrientationPicker, selectOrientation
        // We now use ghost piece interaction
        function hideOrientationPicker() {
            ghostPiece = null;
            renderBoard();
        }

        function updatePlayerConfig() {
            const count = parseInt(document.getElementById('player-count').value);
            const container = document.getElementById('player-config-list');
            let html = '';
            
            for (let i = 0; i < count; i++) {
                const isAI = players[i].type === 'ai';
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="width: 12px; height: 12px; background: ${COLORS[i]}; border-radius: 2px;"></div>
                            <span>${COLOR_NAMES[i]}</span>
                        </div>
                        <select id="p${i}-type" style="background: #1e293b; color: #94a3b8; border: 1px solid #334155; border-radius: 4px; font-size: 0.75rem;">
                            <option value="human" ${!isAI ? 'selected' : ''}>Human</option>
                            <option value="ai" ${isAI ? 'selected' : ''}>AI</option>
                        </select>
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        function applySetupAndReset() {
            const count = parseInt(document.getElementById('player-count').value);
            
            // Reset players
            players.forEach(p => p.active = false);
            
            for (let i = 0; i < count; i++) {
                const type = document.getElementById(`p${i}-type`).value;
                players[i].active = true;
                players[i].type = type;
            }
            
            // Update game mode for legacy checks (though we should use players array now)
            // If any player is AI, we can consider it 'ai' mode for some UI logic
            gameMode = players.some(p => p.active && p.type === 'ai') ? 'ai' : 'pvp';
            
            resetGame();
        }
        
        // ============================================
        // RENDERING
        // ============================================
        
        function renderBoard() {
            const svg = document.getElementById('game-board');
            
            let html = '';
            
            cells.forEach(cell => {
                const piece = pieces[cell.id];
                const isOccupied = !!piece;
                const isValidTarget = !isOccupied && !gameOver && 
                    (players[currentPlayer].type === 'human');
                
                const { x, y, isUpward, cellSize, height } = cell;
                
                const points = isUpward
                    ? `${x + cellSize/2},${y} ${x},${y + height} ${x + cellSize},${y + height}`
                    : `${x},${y} ${x + cellSize},${y} ${x + cellSize/2},${y + height}`;
                
                // Cell coloring based on zone
                let fillColor = '#1e293b';
                if (cell.isEdge) fillColor = '#1a1f35';
                if (isValidTarget) fillColor = '#172033';
                
                html += `<g class="cell ${isOccupied ? 'occupied' : ''} ${isValidTarget ? 'valid-target' : ''}" 
                    onclick="handleCellClick(${cell.id})">`;
                html += `<polygon points="${points}" fill="${fillColor}" stroke="#334155" stroke-width="1"/>`;
                
                if (piece) {
                    renderPiece(html, piece, x, y, isUpward, cellSize, height);
                } else if (ghostPiece && ghostPiece.cellId === cell.id) {
                    // Render Ghost Piece
                    const ghost = { ...ghostPiece, owner: currentPlayer };
                    html += `<g opacity="0.5" style="pointer-events: none;">`;
                    renderPiece(html, ghost, x, y, isUpward, cellSize, height);
                    html += `</g>`;
                }
                
                html += '</g>';
            });
            
            // Helper to render piece content (extracted to avoid duplication)
            function renderPiece(buffer, p, x, y, isUpward, cellSize, height) {
                const cx = x + cellSize / 2;
                const cy = isUpward ? y + height * 0.6 : y + height * 0.4;
                const visible = getVisibleFaces(p.hiddenFace, p.rotation);
                
                // Glow effect
                html += `<circle cx="${cx}" cy="${cy}" r="14" fill="none" stroke="${COLORS[p.hiddenFace]}" 
                    stroke-width="1" opacity="0.3"/>`;
                
                // Center dot (hidden face)
                html += `<circle cx="${cx}" cy="${cy}" r="5" fill="${COLORS[p.hiddenFace]}" 
                    stroke="#000" stroke-width="1.5"/>`;
                
                // Visible face indicators
                visible.forEach((face, i) => {
                    // Correction for Upward triangles to point to faces instead of vertices
                    // Upward: 90, 210, 330. Downward: -90, 30, 150.
                    const baseAngle = isUpward ? (i * 120 + 90) : (i * 120 - 90);
                    const angle = baseAngle * Math.PI / 180;
                    
                    html += `<line x1="${cx + Math.cos(angle) * 7}" y1="${cy + Math.sin(angle) * 7}" 
                        x2="${cx + Math.cos(angle) * 13}" y2="${cy + Math.sin(angle) * 13}" 
                        stroke="${COLORS[face]}" stroke-width="3" stroke-linecap="round"/>`;
                });
                
                // Owner indicator (tiny corner mark)
                const ownerX = cx + (p.owner === 0 ? -8 : 8);
                html += `<circle cx="${ownerX}" cy="${cy - 8}" r="2" fill="${COLORS[p.owner]}" opacity="0.6"/>`;
            }
            
            svg.innerHTML = html;
            
            // Update viewBox
            const maxX = Math.max(...cells.map(c => c.x)) + 50;
            const maxY = Math.max(...cells.map(c => c.y)) + 50;
            svg.setAttribute('viewBox', `-10 -10 ${maxX + 20} ${maxY + 20}`);
        }
        
        function calculateScores() {
            const scores = { 0: 0, 1: 0, 2: 0, 3: 0 };
            Object.values(pieces).forEach(p => scores[p.hiddenFace]++);
            return scores;
        }
        
        function renderScores() {
            const scores = calculateScores();
            const total = Object.values(pieces).length || 1;
            
            let html = '';
            
            // Active Players
            players.forEach(p => {
                if (!p.active) return;
                const pct = (scores[p.id] / total * 100).toFixed(0);
                html += `<div class="score-row">
                    <div class="score-label">
                        <div class="score-dot" style="background:${COLORS[p.id]};box-shadow:0 0 10px ${COLORS[p.id]}"></div>
                        <span>${COLOR_NAMES[p.id]}${p.type === 'ai' ? ' ü§ñ' : ''}</span>
                    </div>
                    <span class="score-value">${scores[p.id]}</span>
                </div>
                <div class="score-bar">
                    <div class="score-fill" style="width:${pct}%;background:${COLORS[p.id]}"></div>
                </div>`;
            });
            
            html += '<hr class="divider"><div class="neutral-label">Neutral / Inactive</div>';
            
            // Inactive/Neutral
            players.forEach(p => {
                if (p.active) return;
                html += `<div class="score-row">
                    <div class="score-label">
                        <div class="score-dot" style="background:${COLORS[p.id]};width:14px;height:14px;box-shadow:none"></div>
                        <span style="color:#64748b;font-size:0.85rem">${COLOR_NAMES[p.id]}</span>
                    </div>
                    <span class="score-value" style="color:#64748b;font-size:1rem">${scores[p.id]}</span>
                </div>`;
            });
            
            document.getElementById('scores').innerHTML = html;
        }
        
        function renderCurrentPlayer() {
            document.getElementById('current-color').style.background = COLORS[currentPlayer];
            document.getElementById('current-color').style.boxShadow = `0 0 20px ${COLORS[currentPlayer]}`;
            document.getElementById('current-name').textContent = COLOR_NAMES[currentPlayer];
            
            const isAI = players[currentPlayer].type === 'ai';
            document.getElementById('current-type').textContent = isAI ? 'ü§ñ AI' : 'üë§ Human';
            
            const aiBtn = document.getElementById('ai-move-btn');
            aiBtn.style.display = isAI ? 'block' : 'none';
        }
        
        function renderStats() {
            const pieceCount = Object.keys(pieces).length;
            const emptyCount = cells.length - pieceCount;
            
            document.getElementById('stat-pieces').textContent = pieceCount;
            document.getElementById('stat-empty').textContent = emptyCount;
            document.getElementById('stat-exiled').textContent = stats.exiled;
            document.getElementById('stat-destroyed').textContent = stats.destroyed;
        }
        
        function renderAll() {
            renderBoard();
            renderScores();
            renderCurrentPlayer();
            renderStats();
        }
        
        function addLog(message, type = '') {
            gameLog.push({ message, type });
            if (gameLog.length > 15) gameLog.shift();
            
            const container = document.getElementById('game-log');
            container.innerHTML = gameLog.map(l => 
                `<div class="log-entry ${l.type}">${l.message}</div>`
            ).join('');
            container.scrollTop = container.scrollHeight;
        }
        
        // ============================================
        // UTILITIES
        // ============================================
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function determineFirstPlayer() {
            const container = document.getElementById('modal-container');
            
            // Roll until we get an active player
            let winner = -1;
            while (winner === -1 || !players[winner].active) {
                winner = Math.floor(Math.random() * 4);
            }
            
            currentPlayer = winner;
            
            // Show Modal
            container.innerHTML = `
                <div class="modal-overlay">
                    <div class="modal" style="text-align:center; min-width: 300px;">
                        <div class="modal-title">üé≤ First Player Roll</div>
                        <div style="margin: 30px; display: flex; justify-content: center;">
                            <div style="
                                width: 80px; 
                                height: 80px; 
                                background: ${COLORS[winner]}; 
                                border-radius: 50%; 
                                box-shadow: 0 0 30px ${COLORS[winner]};
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 2rem;
                            ">
                                ${players[winner].type === 'ai' ? 'ü§ñ' : 'üë§'}
                            </div>
                        </div>
                        <div style="font-size: 1.2rem; margin-bottom: 20px; color: #e2e8f0;">
                            <span style="color:${COLORS[winner]}; font-weight: bold;">${COLOR_NAMES[winner]}</span> goes first!
                        </div>
                        <button class="btn" onclick="closeFirstPlayerModal()" style="background: #334155; color: white;">Start Game</button>
                    </div>
                </div>
            `;
        }
        
        function closeFirstPlayerModal() {
            document.getElementById('modal-container').innerHTML = '';
            renderAll();
            // If AI starts, trigger AI
            if (players[currentPlayer].type === 'ai') {
                setTimeout(() => executeAITurn(), 500);
            }
        }

        function resetGame() {
            pieces = {};
            currentPlayer = 0;
            gameLog = [];
            selectedCell = null;
            gameOver = false;
            stats = { exiled: 0, destroyed: 0 };
            pendingFleeChoice = null;
            
            document.getElementById('game-log').innerHTML = '<div class="log-empty">Click a cell to begin</div>';
            document.getElementById('modal-container').innerHTML = '';
            document.getElementById('game-over-container').innerHTML = '';
            
            determineFirstPlayer();
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        generateGrid();
        updatePlayerConfig();
        determineFirstPlayer();
        
        console.log('TETRAFLUX v0.2.1 loaded');
        console.log(`Grid: ${cells.length} cells`);
        console.log('Game modes: PvP, vs AI');
    </script>
</body>
</html>
