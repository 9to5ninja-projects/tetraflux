<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRAFLUX - Full Prototype v0.2</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #e2e8f0;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { 
            text-align: center; 
            font-size: 2.5rem; 
            margin-bottom: 0.25rem;
            background: linear-gradient(90deg, #f59e0b, #ef4444, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle { text-align: center; color: #64748b; margin-bottom: 1rem; }
        .game-layout { display: flex; gap: 20px; flex-wrap: wrap; }
        .board-container {
            flex: 1;
            min-width: 600px;
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            padding: 20px;
            position: relative;
            border: 1px solid #334155;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .side-panel { width: 320px; display: flex; flex-direction: column; gap: 12px; }
        .panel {
            background: linear-gradient(180deg, #1e293b 0%, #172033 100%);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #334155;
        }
        .panel-title { 
            color: #64748b; 
            font-size: 0.75rem; 
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px; 
        }
        .current-player {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .color-dot {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            box-shadow: 0 0 20px currentColor;
        }
        .player-name { font-weight: bold; font-size: 1.25rem; }
        .player-type { color: #64748b; font-size: 0.875rem; }
        
        /* Mode selector */
        .mode-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        .mode-btn {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #334155;
            background: #0f172a;
            color: #94a3b8;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        .mode-btn:hover { border-color: #64748b; }
        .mode-btn.active {
            border-color: #3b82f6;
            background: #1e3a5f;
            color: #60a5fa;
        }
        
        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
        }
        .score-label { display: flex; align-items: center; gap: 10px; }
        .score-dot { 
            width: 20px; 
            height: 20px; 
            border-radius: 4px;
            box-shadow: 0 0 10px currentColor;
        }
        .score-value { 
            font-family: 'Courier New', monospace; 
            font-size: 1.25rem;
            font-weight: bold;
        }
        .score-bar {
            height: 4px;
            background: #334155;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }
        .score-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .divider { border: none; border-top: 1px solid #334155; margin: 10px 0; }
        .neutral-label { color: #475569; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em; }
        
        .log-container {
            max-height: 180px;
            overflow-y: auto;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }
        .log-entry { 
            padding: 3px 0; 
            color: #94a3b8;
            border-bottom: 1px solid #1e293b;
        }
        .log-entry.collision { color: #fbbf24; }
        .log-entry.destruction { color: #ef4444; }
        .log-entry.exile { color: #a855f7; }
        .log-entry.cascade { color: #22d3ee; }
        .log-entry.ai { color: #22c55e; }
        .log-empty { color: #475569; font-style: italic; }
        
        .legend { font-size: 0.8rem; line-height: 1.8; }
        .legend-item { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .reset-btn {
            background: linear-gradient(135deg, #7f1d1d, #991b1b);
            color: #fecaca;
        }
        .reset-btn:hover { background: linear-gradient(135deg, #991b1b, #b91c1c); }
        
        .ai-btn {
            background: linear-gradient(135deg, #065f46, #047857);
            color: #a7f3d0;
            margin-bottom: 8px;
        }
        .ai-btn:hover { background: linear-gradient(135deg, #047857, #059669); }
        .ai-btn:disabled { 
            background: #1e293b; 
            color: #475569; 
            cursor: not-allowed; 
        }
        
        /* Modal */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
            z-index: 100;
            backdrop-filter: blur(4px);
        }
        .modal {
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid #475569;
            border-radius: 16px;
            padding: 24px;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .modal-title { text-align: center; font-weight: bold; font-size: 1.1rem; margin-bottom: 8px; }
        .modal-hint { text-align: center; color: #64748b; font-size: 0.8rem; margin-bottom: 20px; }
        .orientation-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        .orientation-column { text-align: center; }
        .orientation-label { 
            font-size: 0.65rem; 
            color: #64748b; 
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .orientation-btn {
            width: 52px;
            height: 52px;
            border: 2px solid #334155;
            border-radius: 10px;
            background: #0f172a;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 4px auto;
            transition: all 0.2s;
        }
        .orientation-btn:hover { 
            border-color: #22d3ee; 
            background: #164e63;
            transform: scale(1.05);
        }
        .orientation-btn.recommended { 
            border-color: #eab308; 
            background: #422006;
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.3);
        }
        .cancel-btn {
            width: 100%;
            padding: 10px;
            margin-top: 16px;
            background: #334155;
            color: #94a3b8;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
        }
        .cancel-btn:hover { background: #475569; }
        
        /* Flee choice modal */
        .modal-overlay.interactive {
            background: rgba(0,0,0,0.2);
            pointer-events: none;
        }
        .modal-overlay.interactive .flee-modal {
            pointer-events: auto;
        }
        .flee-modal {
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid #f59e0b;
            border-radius: 16px;
            padding: 24px;
            max-width: 350px;
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.3);
        }
        .flee-btn {
            padding: 12px 20px;
            margin: 6px;
            border: 2px solid #475569;
            border-radius: 8px;
            background: #1e293b;
            color: #e2e8f0;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .flee-btn:hover, .flee-btn.selected {
            border-color: #22d3ee;
            background: #164e63;
        }
        .flee-btn.exile {
            border-color: #a855f7;
            color: #c4b5fd;
        }
        .flee-btn.exile:hover, .flee-btn.exile.selected {
            background: #3b0764;
        }
        
        /* Stats panel */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .stat-box {
            background: #0f172a;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
        .stat-label { font-size: 0.65rem; color: #64748b; text-transform: uppercase; }
        
        /* Animation for cascades */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .cascading { animation: pulse 0.3s ease-in-out; }
        
        /* Game over */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid #eab308;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 0 60px rgba(234, 179, 8, 0.4);
        }
        .game-over h2 { font-size: 2rem; margin-bottom: 10px; color: #fbbf24; }
        .winner-display { font-size: 1.5rem; margin: 20px 0; }
        .final-scores { margin: 20px 0; }
        
        /* Instructions */
        .instructions {
            margin-top: 20px;
            background: linear-gradient(180deg, #1e293b 0%, #172033 100%);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #334155;
        }
        .instructions h3 { margin-bottom: 16px; color: #f59e0b; }
        .rules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            font-size: 0.875rem;
        }
        .rule-box {
            background: #0f172a;
            border-radius: 8px;
            padding: 14px;
            border-left: 3px solid #3b82f6;
        }
        .rule-title { font-weight: 600; color: #e2e8f0; margin-bottom: 6px; }
        .rule-text { color: #94a3b8; line-height: 1.5; }
        
        /* SVG styles */
        .cell { transition: all 0.15s; }
        .cell polygon { transition: all 0.15s; }
        .cell.valid-target { cursor: pointer; }
        .cell.valid-target:hover polygon { fill: #0e7490 !important; }
        .cell.occupied { cursor: default; }
        
        /* Flee Target Styles */
        .cell.flee-target { cursor: pointer; }
        .cell.flee-target polygon {
            fill: #059669 !important;
            stroke: #34d399 !important;
            stroke-width: 2;
        }
        .cell.flee-target:hover polygon, .cell.flee-target.selected polygon {
            fill: #10b981 !important;
            stroke: #6ee7b7 !important;
            stroke-width: 3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚¨° TETRAFLUX ‚¨°</h1>
        <p class="subtitle">Strategic Pyramid Warfare ‚Äî Full Prototype v0.2</p>
        
        <div class="game-layout">
            <div class="board-container" id="board-container">
                <svg id="game-board"></svg>
                <div id="modal-container"></div>
                <div id="game-over-container"></div>
            </div>
            
            <div class="side-panel">
                <!-- Game Setup -->
                <div class="panel">
                    <div class="panel-title">Game Setup</div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 0.8rem; color: #94a3b8;">Board Size:</span>
                            <select id="board-size" onchange="updateBoardSize()" style="background: #0f172a; color: #e2e8f0; border: 1px solid #334155; padding: 4px; border-radius: 4px;">
                                <option value="1">Small (6)</option>
                                <option value="2">Medium (24)</option>
                                <option value="3">Large (54)</option>
                                <option value="4" selected>X-Large (96)</option>
                            </select>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 0.8rem; color: #94a3b8;">Players:</span>
                            <select id="player-count" onchange="updatePlayerConfig()" style="background: #0f172a; color: #e2e8f0; border: 1px solid #334155; padding: 4px; border-radius: 4px;">
                                <option value="2">2 Players</option>
                                <option value="3">3 Players</option>
                                <option value="4">4 Players</option>
                            </select>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px;">
                            <span style="font-size: 0.8rem; color: #94a3b8;">Castle Mode:</span>
                            <input type="checkbox" id="castle-mode" onchange="updateCastleMode()" style="cursor: pointer;">
                        </div>
                        <div id="player-config-list" style="display: flex; flex-direction: column; gap: 4px;">
                            <!-- Populated by JS -->
                        </div>
                        <button class="btn" onclick="applySetupAndReset()" style="background: #3b82f6; color: white; padding: 8px; font-size: 0.8rem; margin-top: 4px;">
                            Apply & Restart
                        </button>
                    </div>
                </div>

                <!-- Current Player -->
                <div class="panel">
                    <div class="panel-title">Current Turn</div>
                    <div class="current-player">
                        <div class="color-dot" id="current-color"></div>
                        <div>
                            <div class="player-name" id="current-name">Red</div>
                            <div class="player-type" id="current-type">Human</div>
                        </div>
                    </div>
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 8px;">
                        Shortcuts: <span style="color: #e2e8f0; font-weight: bold;">R</span> = Rotate, <span style="color: #e2e8f0; font-weight: bold;">F</span> = Flip
                    </div>
                    <button class="btn ai-btn" id="ai-move-btn" onclick="executeAITurn()" style="margin-top: 12px; display: none;">
                        ü§ñ Execute AI Move
                    </button>
                </div>
                
                <!-- Scores -->
                <div class="panel">
                    <div class="panel-title">Hidden Face Score</div>
                    <div id="scores"></div>
                </div>
                
                <!-- Game Stats -->
                <div class="panel">
                    <div class="panel-title">Board Statistics</div>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value" id="stat-pieces">0</div>
                            <div class="stat-label">Pieces</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="stat-empty">0</div>
                            <div class="stat-label">Empty</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="stat-exiled">0</div>
                            <div class="stat-label">Exiled</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="stat-destroyed">0</div>
                            <div class="stat-label">Destroyed</div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Log -->
                <div class="panel">
                    <div class="panel-title">Event Log</div>
                    <div class="log-container" id="game-log">
                        <div class="log-empty">Click a cell to begin</div>
                    </div>
                </div>
                
                <!-- Legend -->
                <div class="panel">
                    <div class="panel-title">Piece Legend</div>
                    <div class="legend">
                        <div class="legend-item">
                            <svg width="20" height="20"><circle cx="10" cy="10" r="6" fill="#eab308" stroke="#000" stroke-width="1"/></svg>
                            <span>Center = Hidden face (scoring)</span>
                        </div>
                        <div class="legend-item">
                            <svg width="20" height="20"><line x1="2" y1="10" x2="18" y2="10" stroke="#3b82f6" stroke-width="4" stroke-linecap="round"/></svg>
                            <span>Lines = Visible faces (collision)</span>
                        </div>
                    </div>
                </div>
                
                <!-- Controls -->
                <button class="btn reset-btn" onclick="resetGame()">üîÑ Reset Game</button>
            </div>
        </div>
        
        <div class="instructions">
            <h3>‚ö° Game Mechanics</h3>
            <div class="rules-grid">
                <div class="rule-box">
                    <div class="rule-title">üéØ Objective</div>
                    <div class="rule-text">Hide your color face-down on as many pieces as possible. Score = count of your color in hidden position across ALL pieces.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üí• Collision</div>
                    <div class="rule-text">When visible faces of same color touch, the stationary piece is REPELLED. The player to the LEFT of the attacker decides where it flees.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üåä Cascade</div>
                    <div class="rule-text">Repelled pieces may cause new collisions, triggering chain reactions. All cascades resolve before turn ends.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üè∞ Castle Defense</div>
                    <div class="rule-text">If a piece is designated as a Castle, the OWNER always decides where it flees, ignoring the "Left Player" rule.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üö™ Exile</div>
                    <div class="rule-text">Pieces pushed off the board are EXILED ‚Äî removed from play. Edge positions are vulnerable but always have an escape route.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">üíÄ Destruction</div>
                    <div class="rule-text">If a piece cannot flee (fully surrounded, no edges), BOTH colliding pieces are destroyed. Mutual annihilation.</div>
                </div>
                <div class="rule-box">
                    <div class="rule-title">ü§ù Hidden Cooperation</div>
                    <div class="rule-text">Aggressive play is volatile ‚Äî cascades are unpredictable. Stable boards preserve everyone's scores. Fight in the middle, leave edges peaceful.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // TETRAFLUX - Complete Game Engine v0.2
        // ============================================
        
        // Constants
        const COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#eab308'];
        const COLOR_NAMES = ['Red', 'Blue', 'Green', 'Yellow'];
        let BOARD_SIZE = 4; // 1=Small(6), 2=Medium(24), 3=Large(54), 4=X-Large(96)
        
        // Tetrahedron face relationships
        // When tumbling over an edge, the hidden face changes deterministically
        // Face indices: 0=Red, 1=Blue, 2=Green, 3=Yellow
        // Edge indices for each face: 0=left, 1=right, 2=back
        const FLIP_MAP = {
            // [currentHidden][edgeIndex] = newHidden
            0: [1, 2, 3], // Red hidden, flip over edge 0/1/2 ‚Üí Blue/Green/Yellow hidden
            1: [0, 3, 2], // Blue hidden
            2: [3, 0, 1], // Green hidden
            3: [2, 1, 0], // Yellow hidden
        };
        
        // Game State
        let cells = [];
        let pieces = {};
        let currentPlayer = 0;
        let selectedCell = null;
        let gameLog = [];
        let gameMode = 'pvp'; // 'pvp' or 'ai'
        let gameOver = false;
        let stats = { exiled: 0, destroyed: 0 };
        let pendingFleeChoice = null;
        let castleMode = false;
        
        // New State for v0.2.1
        let ghostPiece = null; // { cellId, hiddenFace, rotation }
        let players = [
            { id: 0, type: 'human', active: true },
            { id: 1, type: 'human', active: true },
            { id: 2, type: 'human', active: false },
            { id: 3, type: 'human', active: false }
        ];
        
        // ============================================
        // GRID GENERATION
        // ============================================
        
        function generateGrid() {
            cells = [];
            let id = 0;
            const cellSize = 36;
            const height = cellSize * Math.sqrt(3) / 2;
            const totalRows = BOARD_SIZE * 2; 
            
            // Max width at middle (rows BOARD_SIZE-1 and BOARD_SIZE)
            // N=1 -> 3, N=2 -> 7, N=3 -> 11, N=4 -> 15
            const maxCols = 4 * BOARD_SIZE - 1;
            
            for (let row = 0; row < totalRows; row++) {
                let distFromMiddle;
                let isTopHalf = row < BOARD_SIZE;
                
                if (isTopHalf) {
                    distFromMiddle = (BOARD_SIZE - 1) - row;
                } else {
                    distFromMiddle = row - BOARD_SIZE;
                }
                
                // Count decreases by 2 for each step away from middle
                const count = maxCols - (2 * distFromMiddle);
                
                // Calculate offset to center the row
                const offsetUnits = distFromMiddle; 
                
                for (let col = 0; col < count; col++) {
                    // Determine orientation
                    let isUpward;
                    if (isTopHalf) {
                        // Top rows start with Upward (A)
                        // Col 0=Up, 1=Down, 2=Up...
                        isUpward = col % 2 === 0;
                    } else {
                        // Bottom rows start with Downward (V)
                        // Col 0=Down, 1=Up, 2=Down...
                        isUpward = col % 2 !== 0;
                    }
                    
                    // Calculate coordinates
                    const x = (offsetUnits + col) * (cellSize / 2);
                    const y = row * height;
                    
                    cells.push({
                        id: id++,
                        row,
                        col, // relative col in row
                        isUpward,
                        x,
                        y,
                        cellSize,
                        height
                    });
                }
            }
            
            // Calculate isEdge
            const getNeighborCount = (cell, allCells) => {
                let count = 0;
                allCells.forEach(c => {
                    if (c.id === cell.id) return;
                    const dx = Math.abs(c.x - cell.x);
                    const dy = Math.abs(c.y - cell.y);
                    if (dx <= cellSize * 0.6 && dy <= height * 1.1 && (dx + dy) < cellSize * 1.2) {
                        count++;
                    }
                });
                return count;
            };
            
            cells.forEach(cell => {
                const neighbors = getNeighborCount(cell, cells);
                cell.isEdge = neighbors < 3;
            });
        }
        
        // ============================================
        // TETRAHEDRON MECHANICS
        // ============================================
        
        function getVisibleFaces(hiddenFace, rotation) {
            const allFaces = [0, 1, 2, 3];
            const visible = allFaces.filter(f => f !== hiddenFace);
            const rotated = [...visible];
            for (let i = 0; i < rotation; i++) {
                rotated.push(rotated.shift());
            }
            return rotated; // [edge0, edge1, edge2]
        }
        
        function flipPiece(piece, edgeIndex) {
            // Determine new hidden face after tumbling over given edge
            const newHidden = FLIP_MAP[piece.hiddenFace][edgeIndex];
            // Rotation also changes - simplified: increment by 1
            const newRotation = (piece.rotation + 1) % 3;
            return {
                ...piece,
                hiddenFace: newHidden,
                rotation: newRotation
            };
        }
        
        // ============================================
        // ADJACENCY & COLLISION
        // ============================================
        
        function findAdjacent(cellId) {
            const cell = cells.find(c => c.id === cellId);
            if (!cell) return [];
            
            const adjacent = [];
            const { cellSize, height } = cell;
            
            cells.forEach(c => {
                if (c.id === cellId) return;
                const dx = Math.abs(c.x - cell.x);
                const dy = Math.abs(c.y - cell.y);
                
                // Adjacent triangles share an edge
                // Vertical neighbor: dx=0.5, dy=0.866 (approx). Sum = 1.366
                // Horizontal neighbor: dx=0.5, dy=0. Sum = 0.5
                if (dx <= cellSize * 0.6 && dy <= height * 1.1 && (dx + dy) < cellSize * 1.5) {
                    let edgeIndex = -1;
                    
                    if (cell.isUpward) {
                        // Upward ^ : Can only have neighbors Left, Right, Bottom
                        // Top neighbor is a VERTEX connection, not an edge.
                        if (c.y > cell.y) edgeIndex = 2; // Bottom
                        else if (Math.abs(c.y - cell.y) < 1) { // Same row
                            if (c.x < cell.x) edgeIndex = 0; // Left
                            else edgeIndex = 1; // Right
                        }
                    } else {
                        // Downward v : Can only have neighbors Left, Right, Top
                        // Bottom neighbor is a VERTEX connection, not an edge.
                        if (c.y < cell.y) edgeIndex = 2; // Top
                        else if (Math.abs(c.y - cell.y) < 1) { // Same row
                            if (c.x < cell.x) edgeIndex = 0; // Left
                            else edgeIndex = 1; // Right
                        }
                    }
                    
                    if (edgeIndex !== -1) {
                        adjacent.push({ cell: c, edgeIndex });
                    }
                }
            });
            
            return adjacent;
        }
        
        function getFleeDirections(cellId) {
            const adjacent = findAdjacent(cellId);
            const directions = [];
            
            // Check each adjacent position (Valid Moves)
            adjacent.forEach(({ cell: adjCell, edgeIndex }) => {
                if (!pieces[adjCell.id]) {
                    directions.push({
                        targetCell: adjCell,
                        edgeIndex,
                        isExile: false
                    });
                }
            });
            
            // Check for edge exile (Missing Neighbors)
            // A triangle has 3 edges: 0, 1, 2.
            // If a neighbor is missing in any direction, it's an exile path.
            [0, 1, 2].forEach(edgeIndex => {
                if (!adjacent.some(a => a.edgeIndex === edgeIndex)) {
                    directions.push({
                        targetCell: null,
                        edgeIndex,
                        isExile: true
                    });
                }
            });
            
            return directions;
        }
        
        function getFaceAt(piece, edgeIndex) {
            return getVisibleFaces(piece.hiddenFace, piece.rotation)[edgeIndex];
        }

        function getOpposingEdge(edgeIndex) {
            // 0 (Left) <-> 1 (Right)
            // 1 (Right) <-> 0 (Left)
            // 2 (Vertical) <-> 2 (Vertical)
            if (edgeIndex === 2) return 2;
            return edgeIndex === 0 ? 1 : 0;
        }
        
        // ============================================
        // CASCADE RESOLUTION
        // ============================================
        
        function resolveCollisions(triggerCellId, newPieceCellId) {
            const cascadeQueue = [];
            
            // Helper to check specific edge collision
            const checkEdgeCollision = (p1, p2, edgeIndex) => {
                const f1 = getFaceAt(p1, edgeIndex);
                const f2 = getFaceAt(p2, getOpposingEdge(edgeIndex));
                return f1 === f2 ? f1 : null;
            };

            // Initial collision check
            const adjacent = findAdjacent(triggerCellId);
            adjacent.forEach(({ cell: adjCell, edgeIndex }) => {
                if (adjCell.id === newPieceCellId) return; // Don't check against the piece that just moved here
                if (pieces[adjCell.id] && pieces[triggerCellId]) {
                    const collision = checkEdgeCollision(pieces[triggerCellId], pieces[adjCell.id], edgeIndex);
                    if (collision !== null) {
                        cascadeQueue.push({
                            attackerId: triggerCellId,
                            defenderId: adjCell.id,
                            color: collision
                        });
                    }
                }
            });
            
            // Also check if the new piece causes collisions
            if (newPieceCellId !== triggerCellId) {
                const newAdjacent = findAdjacent(newPieceCellId);
                newAdjacent.forEach(({ cell: adjCell, edgeIndex }) => {
                    if (adjCell.id === triggerCellId) return;
                    if (pieces[adjCell.id] && pieces[newPieceCellId]) {
                        const collision = checkEdgeCollision(pieces[newPieceCellId], pieces[adjCell.id], edgeIndex);
                        if (collision !== null && !cascadeQueue.some(c => c.defenderId === adjCell.id)) {
                            cascadeQueue.push({
                                attackerId: newPieceCellId,
                                defenderId: adjCell.id,
                                color: collision
                            });
                        }
                    }
                });
            }
            
            return cascadeQueue;
        }
        
        async function processCascade(collision) {
            const { attackerId, defenderId, color } = collision;
            const defender = pieces[defenderId];
            const attacker = pieces[attackerId];
            
            if (!defender) return []; // Already removed
            
            addLog(`üí• ${COLOR_NAMES[color]} collision!`, 'collision');
            
            const fleeOptions = getFleeDirections(defenderId);
            
            if (fleeOptions.length === 0) {
                // Mutual destruction
                addLog(`üíÄ Mutual destruction!`, 'destruction');
                
                if (castleMode) {
                    if (attacker && attacker.isCastle) eliminatePlayer(attacker.owner);
                    if (defender.isCastle) eliminatePlayer(defender.owner);
                }

                delete pieces[attackerId];
                delete pieces[defenderId];
                stats.destroyed += 2;
                return [];
            }
            
            // Determine flee direction
            let chosenFlee;
            
            if (fleeOptions.length === 1) {
                chosenFlee = fleeOptions[0];
            } else {
                // Determine Decision Maker
                // Rule: Player to the left of the ATTACKER decides.
                // Exception: If it is a "Castle" (defender.isCastle), the OWNER decides.
                
                let decisionMakerId;
                
                if (defender.isCastle) {
                    decisionMakerId = defender.owner;
                    addLog(`üè∞ Castle defense! Owner decides.`, 'info');
                } else {
                    // Attacker might be gone (mutual destruction previously?), but we have the ID.
                    // If attacker is gone, we use the owner from the collision context if possible, 
                    // but pieces[attackerId] might be undefined.
                    // However, processCascade is called immediately, so attacker should exist unless destroyed in parallel?
                    // But we handle one collision at a time.
                    // Wait, if A hits B, and B hits C.
                    // When processing A->B. A exists.
                    // When processing B->C. B exists (it moved).
                    
                    const attackerOwner = attacker ? attacker.owner : currentPlayer; // Fallback to current player if attacker missing
                    decisionMakerId = getNextActivePlayer(attackerOwner);
                }
                
                const decisionMaker = players[decisionMakerId];
                const defenderOwner = defender.owner;
                
                addLog(`‚öñ ${COLOR_NAMES[decisionMakerId]} decides flee for ${COLOR_NAMES[defenderOwner]}`, 'info');

                if (decisionMaker.type === 'ai') {
                    // AI chooses flee direction
                    chosenFlee = aiChooseFleeDirection(fleeOptions, defenderId, decisionMakerId);
                    addLog(`ü§ñ AI chose flee direction`, 'ai');
                } else if (decisionMaker.type === 'human') {
                    // Human chooses
                    chosenFlee = await humanChooseFleeDirection(fleeOptions, defenderId, decisionMakerId);
                } else {
                    // Fallback
                    chosenFlee = fleeOptions.find(f => !f.isExile) || fleeOptions[0];
                }
            }
            
            // Execute flee
            if (chosenFlee.isExile) {
                addLog(`üö™ Piece exiled from board!`, 'exile');
                
                if (castleMode && defender.isCastle) {
                    eliminatePlayer(defender.owner);
                }

                delete pieces[defenderId];
                stats.exiled++;
                return [];
            } else {
                // Flip and move
                const flippedPiece = flipPiece(defender, chosenFlee.edgeIndex);
                delete pieces[defenderId];
                pieces[chosenFlee.targetCell.id] = flippedPiece;
                
                addLog(`‚Ü™ Piece flipped to cell ${chosenFlee.targetCell.id}`, 'cascade');
                
                // Check for new collisions at destination
                renderBoard();
                await sleep(200);
                
                return resolveCollisions(chosenFlee.targetCell.id, chosenFlee.targetCell.id);
            }
        }
        
        function humanChooseFleeDirection(options, defenderId, decisionMakerId) {
            return new Promise(resolve => {
                pendingFleeChoice = { options, defenderId, resolve, selectedIndex: 0, decisionMakerId };
                showFleeChoiceModal(options, defenderId, decisionMakerId);
                renderBoard(); // Re-render to show highlights
            });
        }
        
        function showFleeChoiceModal(options, defenderId, decisionMakerId) {
            const container = document.getElementById('modal-container');
            const defenderOwner = pieces[defenderId]?.owner;
            const decisionMakerName = COLOR_NAMES[decisionMakerId];
            const defenderName = COLOR_NAMES[defenderOwner];
            
            let title = `‚ö° ${decisionMakerName} Decides!`;
            let hint = `${decisionMakerName} chooses where ${defenderName}'s piece flees:`;
            
            if (decisionMakerId === defenderOwner) {
                title = `‚ö° Save Your Piece!`;
                hint = `Choose where your piece flees:`;
            }
            
            let html = `<div class="modal-overlay interactive">
                <div class="flee-modal" style="border-color: ${COLORS[decisionMakerId]}">
                    <div class="modal-title" style="color: ${COLORS[decisionMakerId]}">${title}</div>
                    <div class="modal-hint">${hint}</div>
                    <div class="modal-hint" style="font-size: 0.7rem; margin-top: -10px;">(TAB to cycle, ENTER/SPACE to confirm, or Click Green Cell)</div>
                    <div style="display: flex; flex-wrap: wrap; justify-content: center;" id="flee-btn-container">`;
            
            options.forEach((opt, idx) => {
                const isSelected = idx === 0 ? 'selected' : '';
                if (opt.isExile) {
                    html += `<button class="flee-btn exile ${isSelected}" id="flee-btn-${idx}" onclick="selectFleeDirection(${idx})">
                        üö™ Exile (Off Board)
                    </button>`;
                } else {
                    html += `<button class="flee-btn ${isSelected}" id="flee-btn-${idx}" onclick="selectFleeDirection(${idx})">
                        ‚Üí Cell ${opt.targetCell.id}
                    </button>`;
                }
            });
            
            html += `</div></div></div>`;
            container.innerHTML = html;
        }
        
        function updateFleeModalSelection() {
            if (!pendingFleeChoice) return;
            const idx = pendingFleeChoice.selectedIndex;
            
            // Update buttons
            const container = document.getElementById('flee-btn-container');
            if (container) {
                Array.from(container.children).forEach((btn, i) => {
                    if (i === idx) btn.classList.add('selected');
                    else btn.classList.remove('selected');
                });
            }
        }

        function selectFleeDirection(index) {
            if (pendingFleeChoice) {
                const choice = pendingFleeChoice.options[index];
                document.getElementById('modal-container').innerHTML = '';
                pendingFleeChoice.resolve(choice);
                pendingFleeChoice = null;
            }
        }
        
        // ============================================
        // AI OPPONENT
        // ============================================
        
        function aiChooseFleeDirection(options, defenderId, decisionMakerId) {
            const piece = pieces[defenderId];
            if (!piece) return options[0];
            
            const isSelf = decisionMakerId === piece.owner;
            
            if (isSelf) {
                // AI is saving its own piece (Castle rule or self-collision)
                // Priority: 
                // 1. Avoid Exile
                // 2. Hide own color
                // 3. Move to interior
                
                const nonExile = options.filter(o => !o.isExile);
                if (nonExile.length > 0) {
                    // Prefer interior positions
                    const interior = nonExile.filter(o => !o.targetCell.isEdge);
                    if (interior.length > 0) return interior[0];
                    return nonExile[0];
                }
                return options[0]; // Must exile
            } else {
                // AI is deciding for an opponent's piece
                // Priority:
                // 1. Exile the piece!
                // 2. Move to edge (vulnerable)
                // 3. Move to cause bad collision? (Too complex for now)
                
                const exileOption = options.find(o => o.isExile);
                if (exileOption) return exileOption;
                
                // If can't exile, move to edge
                const edgeOption = options.find(o => o.targetCell.isEdge);
                if (edgeOption) return edgeOption;
                
                return options[0];
            }
        }
        
        function evaluatePlacement(cellId, hiddenFace, rotation) {
            let score = 0;
            const piece = { hiddenFace, rotation, owner: currentPlayer };
            const cell = cells.find(c => c.id === cellId);
            
            // Priority 1: Bury AI color (Primary Objective)
            if (hiddenFace === currentPlayer) score += 100;
            
            // Priority 2: Centrality (Control the center)
            // Calculate distance from center of board
            // Board center is approx at row = BOARD_SIZE, col = middle
            // Simple heuristic: Higher row/col index means further out? No.
            // Use cell.row and cell.col relative to board size.
            // Or just use neighbor count as proxy for centrality?
            // Center cells have 3 neighbors. Edge cells have < 3.
            // But we want "Deep" center.
            // Let's use the pre-calculated coordinates.
            // Find board center coordinates
            const boardCenterY = (BOARD_SIZE * 2 * cell.height) / 2;
            // Max width is roughly (4 * BOARD_SIZE * cellSize)
            const boardCenterX = (4 * BOARD_SIZE * cell.cellSize) / 2; // Approx
            
            const dist = Math.sqrt((cell.x - boardCenterX)**2 + (cell.y - boardCenterY)**2);
            const maxDist = boardCenterX; // Approx
            const centralityScore = Math.max(0, (1 - dist/maxDist) * 40);
            score += centralityScore;
            
            // Priority 3: Aggression & Safety (Look ahead 1 step)
            const adjacent = findAdjacent(cellId);
            let collisionRisk = 0;
            let attackBonus = 0;
            
            adjacent.forEach(({ cell: adjCell, edgeIndex }) => {
                if (pieces[adjCell.id]) {
                    const f1 = getFaceAt(piece, edgeIndex);
                    const f2 = getFaceAt(pieces[adjCell.id], getOpposingEdge(edgeIndex));
                    
                    if (f1 === f2) {
                        // Collision!
                        // If I am repelled (my piece moves), that's risky/bad usually
                        // Unless I want to move? But usually we want to stick.
                        // In this game, BOTH repel? No, "stationary piece is REPELLED".
                        // Wait, the rule is "When visible faces of same color touch, the stationary piece is REPELLED".
                        // The "stationary" piece is the one ALREADY ON THE BOARD.
                        // The PLACED piece (attacker) stays?
                        // "The stationary piece is REPELLED" -> The defender moves.
                        
                        // So placing a piece that causes collision is an ATTACK.
                        // Attacking is good if we displace an enemy.
                        if (pieces[adjCell.id].owner !== currentPlayer) {
                            attackBonus += 25;
                            // Bonus if we push them to exile? (Hard to calc, but edge proximity helps)
                            if (adjCell.isEdge) attackBonus += 15;
                        } else {
                            // Displacing self? Might be okay to reposition, but usually chaotic.
                            collisionRisk += 10;
                        }
                    }
                }
            });
            
            score += attackBonus;
            score -= collisionRisk;
            
            // Priority 4: Randomness to break ties and prevent sequential placement
            score += Math.random() * 10;
            
            return score;
        }
        
        function getAIMove() {
            const emptyCells = cells.filter(c => !pieces[c.id]);
            if (emptyCells.length === 0) return null;
            
            // Shuffle empty cells to prevent positional bias when scores are tied
            for (let i = emptyCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]];
            }
            
            let bestMove = null;
            let bestScore = -Infinity;
            
            // Evaluate a subset if too many? No, 96 is small enough.
            emptyCells.forEach(cell => {
                // Try all orientations
                for (let hidden = 0; hidden < 4; hidden++) {
                    for (let rot = 0; rot < 3; rot++) {
                        const score = evaluatePlacement(cell.id, hidden, rot);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { cellId: cell.id, hiddenFace: hidden, rotation: rot };
                        }
                    }
                }
            });
            
            return bestMove;
        }
        
        // Simulation Tool
        async function runSimulation(games = 10) {
            console.log(`Starting simulation of ${games} games...`);
            const originalMode = gameMode;
            const originalDelay = window.sleep;
            
            // Speed up
            window.sleep = (ms) => new Promise(r => setTimeout(r, 0));
            
            let aiWins = 0;
            let turns = 0;
            
            for (let i = 0; i < games; i++) {
                resetGame();
                // Force all AI
                players.forEach(p => p.type = 'ai');
                
                while (!gameOver && turns < 1000) {
                    await executeAITurn();
                    turns++;
                }
                console.log(`Game ${i+1} finished.`);
            }
            
            // Restore
            window.sleep = originalDelay;
            console.log("Simulation complete.");
        }
        
        async function executeAITurn() {
            if (gameOver || players[currentPlayer].type !== 'ai') return;
            
            document.getElementById('ai-move-btn').disabled = true;
            
            await sleep(500);
            
            const move = getAIMove();
            if (!move) {
                checkGameOver();
                return;
            }
            
            addLog(`ü§ñ AI placing piece...`, 'ai');
            await sleep(300);
            
            await placePiece(move.cellId, move.hiddenFace, move.rotation);
            
            document.getElementById('ai-move-btn').disabled = false;
        }
        
        // ============================================
        // GAME FLOW
        // ============================================
        
        async function placePiece(cellId, hiddenFace, rotation) {
            if (pieces[cellId] || gameOver) return;
            
            const isFirstPiece = !Object.values(pieces).some(p => p.owner === currentPlayer);
            const isCastle = castleMode && isFirstPiece;

            const newPiece = { 
                hiddenFace, 
                rotation, 
                owner: currentPlayer,
                isCastle
            };
            
            pieces[cellId] = newPiece;
            
            if (isCastle) addLog(`üè∞ ${COLOR_NAMES[currentPlayer]} Castle placed!`, 'info');
            else addLog(`${COLOR_NAMES[currentPlayer]} placed (hiding ${COLOR_NAMES[hiddenFace]})`);
            
            renderBoard();
            await sleep(100);
            
            // Check for collisions
            let cascadeQueue = resolveCollisions(cellId, cellId);
            
            while (cascadeQueue.length > 0) {
                const collision = cascadeQueue.shift();
                const newCollisions = await processCascade(collision);
                cascadeQueue.push(...newCollisions);
                renderBoard();
                await sleep(150);
            }
            
            hideOrientationPicker();
            
            if (!checkGameOver()) {
                // Find next active player
                let nextPlayer = (currentPlayer + 1) % 4;
                while (!players[nextPlayer].active) {
                    nextPlayer = (nextPlayer + 1) % 4;
                }
                currentPlayer = nextPlayer;
                
                renderAll();
                
                // Auto-trigger AI if it's AI's turn
                if (players[currentPlayer].type === 'ai') {
                    setTimeout(() => executeAITurn(), 500);
                }
            }
        }
        
        function checkGameOver() {
            // Check for Last Man Standing in Castle Mode
            if (castleMode) {
                // Count players who started the game (based on UI or some other tracking?)
                // We can check who has pieces OR who is marked active.
                // But at start, no one has pieces.
                // So we rely on 'active' flag.
                // But we need to ensure we don't trigger this before the game starts (0 pieces).
                const totalPieces = Object.keys(pieces).length;
                if (totalPieces > 0) {
                    const activeSurvivors = players.filter(p => p.active);
                    if (activeSurvivors.length <= 1) {
                        gameOver = true;
                        showGameOver();
                        return true;
                    }
                }
            }

            const emptyCells = cells.filter(c => !pieces[c.id]);
            if (emptyCells.length === 0) {
                gameOver = true;
                showGameOver();
                return true;
            }
            return false;
        }
        
        function showGameOver() {
            const scores = calculateScores();
            
            let winner = null;
            let maxScore = -1;
            let isTie = false;
            
            // If Castle Mode and only 1 active survivor
            const activeSurvivors = players.filter(p => p.active);
            if (castleMode && activeSurvivors.length === 1) {
                winner = activeSurvivors[0];
                isTie = false;
            } else {
                players.forEach(p => {
                    // In castle mode, ignore eliminated players
                    if (castleMode && !p.active) return;
                    // In normal mode, only check players who were part of the game
                    // (We need a way to know who was playing originally if we don't use 'active' for elimination in normal mode)
                    // But in normal mode 'active' is only set at start.
                    if (!p.active) return;

                    if (scores[p.id] > maxScore) {
                        maxScore = scores[p.id];
                        winner = p;
                        isTie = false;
                    } else if (scores[p.id] === maxScore) {
                        isTie = true;
                    }
                });
            }
            
            let winnerText, winnerColor;
            if (isTie) {
                winnerText = "It's a Tie!";
                winnerColor = '#94a3b8';
            } else {
                winnerText = `${COLOR_NAMES[winner.id]} Wins!`;
                winnerColor = COLORS[winner.id];
            }
            
            const container = document.getElementById('game-over-container');
            
            let scoresHtml = '<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">';
            players.forEach(p => {
                if (!p.active) return;
                scoresHtml += `
                    <div style="text-align: center;">
                        <div style="color: ${COLORS[p.id]}; font-size: 2rem; font-weight: bold;">${scores[p.id]}</div>
                        <div style="color: #94a3b8;">${COLOR_NAMES[p.id]}</div>
                    </div>
                `;
            });
            scoresHtml += '</div>';

            container.innerHTML = `
                <div class="game-over">
                    <h2>üèÜ Game Over!</h2>
                    <div class="winner-display" style="color: ${winnerColor}">
                        ${winnerText}
                    </div>
                    <div class="final-scores">
                        ${scoresHtml}
                    </div>
                    <button class="btn reset-btn" onclick="resetGame()" style="margin-top: 20px;">
                        üîÑ Play Again
                    </button>
                </div>
            `;
        }
        
        // ============================================
        // UI HANDLERS
        // ============================================
        
        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            
            // Handle Flee Selection Keys
            if (pendingFleeChoice) {
                if (e.key === 'Tab' || e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    const count = pendingFleeChoice.options.length;
                    pendingFleeChoice.selectedIndex = (pendingFleeChoice.selectedIndex + 1) % count;
                    updateFleeModalSelection();
                    renderBoard(); 
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    const count = pendingFleeChoice.options.length;
                    pendingFleeChoice.selectedIndex = (pendingFleeChoice.selectedIndex - 1 + count) % count;
                    updateFleeModalSelection();
                    renderBoard();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    selectFleeDirection(pendingFleeChoice.selectedIndex);
                }
                return;
            }
            
            // Only allow manipulation if it's human turn
            if (players[currentPlayer].type !== 'human') return;

            // D-Pad Navigation
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                moveSelection(e.key);
                return;
            }

            if (!ghostPiece) return;

            switch(e.key.toLowerCase()) {
                case 'r':
                    ghostPiece.rotation = (ghostPiece.rotation + 1) % 3;
                    renderBoard();
                    break;
                case 'f':
                    // Cycle through valid hidden faces
                    ghostPiece.hiddenFace = (ghostPiece.hiddenFace + 1) % 4;
                    renderBoard();
                    break;
                case 'enter':
                    if (ghostPiece) {
                        placePiece(ghostPiece.cellId, ghostPiece.hiddenFace, ghostPiece.rotation);
                    }
                    break;
                case 'escape':
                    ghostPiece = null;
                    renderBoard();
                    break;
            }
        });

        function moveSelection(key) {
            // If no ghost piece, start at center
            if (!ghostPiece) {
                // Find center cell
                const centerRow = Math.floor(BOARD_SIZE);
                const rowCells = cells.filter(c => c.row === centerRow);
                const centerCell = rowCells[Math.floor(rowCells.length / 2)];
                if (centerCell) handleCellClick(centerCell.id);
                return;
            }

            const currentCell = cells.find(c => c.id === ghostPiece.cellId);
            if (!currentCell) return;

            let targetCell = null;
            let bestDist = Infinity;

            // Filter candidates based on direction
            let candidates = [];
            
            if (key === 'ArrowUp') {
                // Look in row above
                candidates = cells.filter(c => c.row === currentCell.row - 1);
            } else if (key === 'ArrowDown') {
                // Look in row below
                candidates = cells.filter(c => c.row === currentCell.row + 1);
            } else if (key === 'ArrowLeft') {
                // Look in same row, to the left
                candidates = cells.filter(c => c.row === currentCell.row && c.x < currentCell.x);
            } else if (key === 'ArrowRight') {
                // Look in same row, to the right
                candidates = cells.filter(c => c.row === currentCell.row && c.x > currentCell.x);
            }

            // Find closest candidate
            candidates.forEach(c => {
                // For Up/Down, minimize X distance
                // For Left/Right, minimize X distance (closest neighbor)
                const dist = Math.abs(c.x - currentCell.x);
                
                // For Left/Right, we want the closest one, so simple min dist works
                // For Up/Down, we also want closest X alignment
                if (dist < bestDist) {
                    bestDist = dist;
                    targetCell = c;
                }
            });
            
            // Special case for Left/Right: we want the *closest* one, not just any
            if (key === 'ArrowLeft' || key === 'ArrowRight') {
                // Sort by distance and pick first
                candidates.sort((a, b) => Math.abs(a.x - currentCell.x) - Math.abs(b.x - currentCell.x));
                targetCell = candidates[0];
            }

            if (targetCell) {
                // Move ghost piece to new cell
                // Preserve rotation/hidden face? Yes.
                ghostPiece.cellId = targetCell.id;
                renderBoard();
            }
        }

        function handleCellClick(cellId) {
            if (pieces[cellId] || gameOver) return;
            
            // Handle Flee Selection Click
            if (pendingFleeChoice) {
                const optionIndex = pendingFleeChoice.options.findIndex(opt => 
                    !opt.isExile && opt.targetCell && opt.targetCell.id === cellId
                );
                
                if (optionIndex !== -1) {
                    selectFleeDirection(optionIndex);
                }
                return;
            }

            if (players[currentPlayer].type === 'ai') return; // AI's turn
            
            // If clicking the same cell with ghost piece, confirm placement
            if (ghostPiece && ghostPiece.cellId === cellId) {
                placePiece(cellId, ghostPiece.hiddenFace, ghostPiece.rotation);
                return;
            }

            // Otherwise, move ghost piece here
            // Default: Hide current player's color, rotation 0
            ghostPiece = {
                cellId,
                hiddenFace: currentPlayer,
                rotation: 0
            };
            renderBoard();
        }
        
        // Deprecated: showOrientationPicker, hideOrientationPicker, selectOrientation
        // We now use ghost piece interaction
        function hideOrientationPicker() {
            ghostPiece = null;
            renderBoard();
        }

        function updateBoardSize() {
            const size = parseInt(document.getElementById('board-size').value);
            BOARD_SIZE = size;
            applySetupAndReset();
        }

        function updateCastleMode() {
            castleMode = document.getElementById('castle-mode').checked;
            // Don't reset game, just update flag for next game or current if early?
            // Better to apply on reset.
        }

        function updatePlayerConfig() {
            const count = parseInt(document.getElementById('player-count').value);
            const container = document.getElementById('player-config-list');
            let html = '';
            
            for (let i = 0; i < count; i++) {
                const isAI = players[i].type === 'ai';
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="width: 12px; height: 12px; background: ${COLORS[i]}; border-radius: 2px;"></div>
                            <span>${COLOR_NAMES[i]}</span>
                        </div>
                        <select id="p${i}-type" style="background: #1e293b; color: #94a3b8; border: 1px solid #334155; border-radius: 4px; font-size: 0.75rem;">
                            <option value="human" ${!isAI ? 'selected' : ''}>Human</option>
                            <option value="ai" ${isAI ? 'selected' : ''}>AI</option>
                        </select>
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        function applySetupAndReset() {
            const count = parseInt(document.getElementById('player-count').value);
            castleMode = document.getElementById('castle-mode').checked;
            
            // Ensure Board Size is synced
            BOARD_SIZE = parseInt(document.getElementById('board-size').value);
            
            // Reset players
            players.forEach(p => p.active = false);
            
            for (let i = 0; i < count; i++) {
                const type = document.getElementById(`p${i}-type`).value;
                players[i].active = true;
                players[i].type = type;
            }
            
            // Update game mode for legacy checks (though we should use players array now)
            // If any player is AI, we can consider it 'ai' mode for some UI logic
            gameMode = players.some(p => p.active && p.type === 'ai') ? 'ai' : 'pvp';
            
            // REGENERATE GRID for new board size
            generateGrid();
            
            resetGame();
        }
        
        // ============================================
        // RENDERING
        // ============================================
        
        function renderBoard() {
            const svg = document.getElementById('game-board');
            
            let html = '';
            
            cells.forEach(cell => {
                const piece = pieces[cell.id];
                const isOccupied = !!piece;
                
                // Flee Selection Logic
                let isFleeTarget = false;
                let isFleeSelected = false;
                
                if (pendingFleeChoice) {
                    const optionIndex = pendingFleeChoice.options.findIndex(opt => 
                        !opt.isExile && opt.targetCell && opt.targetCell.id === cell.id
                    );
                    
                    if (optionIndex !== -1) {
                        isFleeTarget = true;
                        if (optionIndex === pendingFleeChoice.selectedIndex) {
                            isFleeSelected = true;
                        }
                    }
                }

                const isValidTarget = !isOccupied && !gameOver && 
                    (players[currentPlayer].type === 'human') && !pendingFleeChoice;
                
                const { x, y, isUpward, cellSize, height } = cell;
                
                const points = isUpward
                    ? `${x + cellSize/2},${y} ${x},${y + height} ${x + cellSize},${y + height}`
                    : `${x},${y} ${x + cellSize},${y} ${x + cellSize/2},${y + height}`;
                
                // Cell coloring based on zone
                let fillColor = '#1e293b';
                if (cell.isEdge) fillColor = '#1a1f35';
                if (isValidTarget) fillColor = '#172033';
                
                let classes = `cell ${isOccupied ? 'occupied' : ''}`;
                if (isValidTarget) classes += ' valid-target';
                if (isFleeTarget) classes += ' flee-target';
                if (isFleeSelected) classes += ' selected';
                
                html += `<g class="${classes}" onclick="handleCellClick(${cell.id})">`;
                html += `<polygon points="${points}" fill="${fillColor}" stroke="#334155" stroke-width="1"/>`;
                
                if (piece) {
                    renderPiece(html, piece, x, y, isUpward, cellSize, height);
                } else if (ghostPiece && ghostPiece.cellId === cell.id) {
                    // Render Ghost Piece
                    const ghost = { ...ghostPiece, owner: currentPlayer };
                    html += `<g opacity="0.5" style="pointer-events: none;">`;
                    renderPiece(html, ghost, x, y, isUpward, cellSize, height);
                    html += `</g>`;
                }
                
                html += '</g>';
            });
            
            // Helper to render piece content (extracted to avoid duplication)
            function renderPiece(buffer, p, x, y, isUpward, cellSize, height) {
                const cx = x + cellSize / 2;
                const cy = isUpward ? y + height * 0.6 : y + height * 0.4;
                const visible = getVisibleFaces(p.hiddenFace, p.rotation);
                
                // Glow effect
                html += `<circle cx="${cx}" cy="${cy}" r="14" fill="none" stroke="${COLORS[p.hiddenFace]}" 
                    stroke-width="1" opacity="0.3"/>`;
                
                // Center dot (hidden face)
                html += `<circle cx="${cx}" cy="${cy}" r="5" fill="${COLORS[p.hiddenFace]}" 
                    stroke="#000" stroke-width="1.5"/>`;
                
                // Visible face indicators
                visible.forEach((face, i) => {
                    // i is the edgeIndex (0, 1, 2)
                    let angleDeg;
                    if (isUpward) {
                        // 0=Left(210), 1=Right(330), 2=Bottom(90)
                        if (i === 0) angleDeg = 210;
                        else if (i === 1) angleDeg = 330;
                        else angleDeg = 90;
                    } else {
                        // 0=Left(150), 1=Right(30), 2=Top(270)
                        if (i === 0) angleDeg = 150;
                        else if (i === 1) angleDeg = 30;
                        else angleDeg = 270;
                    }
                    
                    const angle = angleDeg * Math.PI / 180;
                    
                    html += `<line x1="${cx + Math.cos(angle) * 7}" y1="${cy + Math.sin(angle) * 7}" 
                        x2="${cx + Math.cos(angle) * 13}" y2="${cy + Math.sin(angle) * 13}" 
                        stroke="${COLORS[face]}" stroke-width="3" stroke-linecap="round"/>`;
                });
                
                // Owner indicator (tiny corner mark)
                const ownerX = cx + (p.owner === 0 ? -8 : 8);
                html += `<circle cx="${ownerX}" cy="${cy - 8}" r="2" fill="${COLORS[p.owner]}" opacity="0.6"/>`;
                
                if (p.isCastle) {
                    html += `<text x="${cx}" y="${cy+4}" text-anchor="middle" font-size="12" fill="white" style="pointer-events:none; text-shadow: 0 0 3px black;">üëë</text>`;
                }
            }
            
            svg.innerHTML = html;
            
            // Update viewBox
            const maxX = Math.max(...cells.map(c => c.x)) + 50;
            const maxY = Math.max(...cells.map(c => c.y)) + 50;
            svg.setAttribute('viewBox', `-10 -10 ${maxX + 20} ${maxY + 20}`);
        }
        
        function calculateScores() {
            const scores = { 0: 0, 1: 0, 2: 0, 3: 0 };
            Object.values(pieces).forEach(p => scores[p.hiddenFace]++);
            return scores;
        }
        
        function renderScores() {
            const scores = calculateScores();
            const total = Object.values(pieces).length || 1;
            
            let html = '';
            
            // Active Players
            players.forEach(p => {
                if (!p.active) return;
                const pct = (scores[p.id] / total * 100).toFixed(0);
                html += `<div class="score-row">
                    <div class="score-label">
                        <div class="score-dot" style="background:${COLORS[p.id]};box-shadow:0 0 10px ${COLORS[p.id]}"></div>
                        <span>${COLOR_NAMES[p.id]}${p.type === 'ai' ? ' ü§ñ' : ''}</span>
                    </div>
                    <span class="score-value">${scores[p.id]}</span>
                </div>
                <div class="score-bar">
                    <div class="score-fill" style="width:${pct}%;background:${COLORS[p.id]}"></div>
                </div>`;
            });
            
            html += '<hr class="divider"><div class="neutral-label">Neutral / Inactive</div>';
            
            // Inactive/Neutral
            players.forEach(p => {
                if (p.active) return;
                html += `<div class="score-row">
                    <div class="score-label">
                        <div class="score-dot" style="background:${COLORS[p.id]};width:14px;height:14px;box-shadow:none"></div>
                        <span style="color:#64748b;font-size:0.85rem">${COLOR_NAMES[p.id]}</span>
                    </div>
                    <span class="score-value" style="color:#64748b;font-size:1rem">${scores[p.id]}</span>
                </div>`;
            });
            
            document.getElementById('scores').innerHTML = html;
        }
        
        function renderCurrentPlayer() {
            document.getElementById('current-color').style.background = COLORS[currentPlayer];
            document.getElementById('current-color').style.boxShadow = `0 0 20px ${COLORS[currentPlayer]}`;
            document.getElementById('current-name').textContent = COLOR_NAMES[currentPlayer];
            
            const isAI = players[currentPlayer].type === 'ai';
            document.getElementById('current-type').textContent = isAI ? 'ü§ñ AI' : 'üë§ Human';
            
            const aiBtn = document.getElementById('ai-move-btn');
            aiBtn.style.display = isAI ? 'block' : 'none';
        }
        
        function renderStats() {
            const pieceCount = Object.keys(pieces).length;
            const emptyCount = cells.length - pieceCount;
            
            document.getElementById('stat-pieces').textContent = pieceCount;
            document.getElementById('stat-empty').textContent = emptyCount;
            document.getElementById('stat-exiled').textContent = stats.exiled;
            document.getElementById('stat-destroyed').textContent = stats.destroyed;
        }
        
        function renderAll() {
            renderBoard();
            renderScores();
            renderCurrentPlayer();
            renderStats();
        }
        
        function addLog(message, type = '') {
            gameLog.push({ message, type });
            if (gameLog.length > 15) gameLog.shift();
            
            const container = document.getElementById('game-log');
            container.innerHTML = gameLog.map(l => 
                `<div class="log-entry ${l.type}">${l.message}</div>`
            ).join('');
            container.scrollTop = container.scrollHeight;
        }
        
        // ============================================
        // UTILITIES
        // ============================================
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getNextActivePlayer(playerId) {
            let next = (playerId + 1) % 4;
            while (!players[next].active) {
                next = (next + 1) % 4;
                // Safety break to prevent infinite loop if no one is active (shouldn't happen)
                if (next === playerId) return playerId;
            }
            return next;
        }
        
        function determineFirstPlayer() {
            const container = document.getElementById('modal-container');
            
            // Roll until we get an active player
            let winner = -1;
            while (winner === -1 || !players[winner].active) {
                winner = Math.floor(Math.random() * 4);
            }
            
            currentPlayer = winner;
            
            // Show Modal
            container.innerHTML = `
                <div class="modal-overlay">
                    <div class="modal" style="text-align:center; min-width: 300px;">
                        <div class="modal-title">üé≤ First Player Roll</div>
                        <div style="margin: 30px; display: flex; justify-content: center;">
                            <div style="
                                width: 80px; 
                                height: 80px; 
                                background: ${COLORS[winner]}; 
                                border-radius: 50%; 
                                box-shadow: 0 0 30px ${COLORS[winner]};
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 2rem;
                            ">
                                ${players[winner].type === 'ai' ? 'ü§ñ' : 'üë§'}
                            </div>
                        </div>
                        <div style="font-size: 1.2rem; margin-bottom: 20px; color: #e2e8f0;">
                            <span style="color:${COLORS[winner]}; font-weight: bold;">${COLOR_NAMES[winner]}</span> goes first!
                        </div>
                        <button class="btn" onclick="closeFirstPlayerModal()" style="background: #334155; color: white;">Start Game</button>
                    </div>
                </div>
            `;
        }
        
        function closeFirstPlayerModal() {
            document.getElementById('modal-container').innerHTML = '';
            renderAll();
            // If AI starts, trigger AI
            if (players[currentPlayer].type === 'ai') {
                setTimeout(() => executeAITurn(), 500);
            }
        }

        function resetGame() {
            pieces = {};
            currentPlayer = 0;
            gameLog = [];
            selectedCell = null;
            gameOver = false;
            stats = { exiled: 0, destroyed: 0 };
            pendingFleeChoice = null;
            
            // Restore player active states based on UI
            const count = parseInt(document.getElementById('player-count').value);
            players.forEach(p => p.active = false);
            for (let i = 0; i < count; i++) {
                players[i].active = true;
            }

            document.getElementById('game-log').innerHTML = '<div class="log-empty">Click a cell to begin</div>';
            document.getElementById('modal-container').innerHTML = '';
            document.getElementById('game-over-container').innerHTML = '';
            
            determineFirstPlayer();
        }
        
        function eliminatePlayer(playerId) {
            if (players[playerId].active) {
                players[playerId].active = false;
                addLog(`üëë ${COLOR_NAMES[playerId]} ELIMINATED (Castle Lost)!`, 'destruction');
                checkGameOver();
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        
        generateGrid();
        updatePlayerConfig();
        determineFirstPlayer();
        
        console.log('TETRAFLUX v0.2.1 loaded');
        console.log(`Grid: ${cells.length} cells`);
        console.log('Game modes: PvP, vs AI');
    </script>
</body>
</html>
